<!DOCTYPE HTML>
<html>
  <head>
    <title>Lightning Java Documentation</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="highlighter/styles/tomorrow-night.css">
    <script src="js/jquery.min.js"></script>
    <script src="highlighter/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="header">
      <div class="wrapper">
        <h1>Lightning Documentation</h1>
      </div>
    </div>
    <div class="wrapper">
      <div class="columns">
        <div class="left">
          <h2>Table of Contents</h2>
          <ul id="table_of_contents"></ul>
        </div>
        <div class="right">
          <!-- BEGIN RIGHT -->
          <section>
        <a name="info"></a>
        <h2>Information</h2>
        <p>Lightning is a simple yet expressive web framework for Java.</p>
        <p>Our design goals are:</p>
        <ul>
          <li>To provide the convenience of save-and-refresh development in Java</li>
          <li>To provide powerful debugging tools that speed up development</li>
          <li>To include a built-in web server that allows developers to get set up quickly by writing purely Java</li>
          <li>To provide APIs that are convenient and easy to learn for both beginners and professionals</li>
          <li>To include the core functionality needed to build secure, scalable modern web applications</li>
          <li>To give developers the freedom to use Lightning with the tools they know and love</li>
        </ul>
        <p>Built-In Features:</p>
        <ul>
          <li>Routing (w/ wildcards and parameters)</li>
          <li>Path-Based Filters (w/ wildcards and parameters)</li>
          <li>Templating (w/ Freemarker by default)</li>
          <li>Emails (via SMTP)</li>
          <li>SSL</li>
          <li>MySQL (w/ connection pooling, transactions)</li>
          <li>Sessions</li>
          <li>Authentication</li>
          <li>Multipart Requests/File Uploads</li>
          <li>Form Validation</li>
          <li>Async Handlers/Server-Sent Events</li>
          <li>Web Sockets</li>
          <li>HTTP2 &amp; HTTP2C Support</li>
          <li>Dependency Injection</li>
          <li>Debug Mode</li>
          <li>...and so much more!</li>
        </ul>
        <p><a href="https://github.com/lightning-framework/lightning" target="_blank">Source (GitHub)</a></p>
      </section>

      <section>
        <a name="examples"></a>
        <h2>Examples</h2>
        <p>Lightning maintains an up to date repository containing code examples, tutorials, and a list of open source projects using the framework.</p>
        <p><a href="https://github.com/lightning-framework/examples" target="_blank">Examples (GitHub)</a></p>
      </section>

      <section>
        <a name="getting_started"></a>
        <h2>Getting Started</h2>

        <p>To use Lightning, simply create a new <a href="https://maven.apache.org/" target="_blank">Maven</a> project and add Lightning as a dependency. In order to use Lightning effectively, you need to follow Maven's <a href="https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html" target="_blank">directory structure conventions</a>. An example <code>pom.xml</code> is included below for your convenience.</p>

        <div class="info-box">If you haven't used Maven before, don't fret! Maven is simply an automated dependency management system for Java that automatically downloads required packages from Maven Central and installs them into your project. All Maven projects contain a <code>pom.xml</code> file that specifies the needed dependencies. Most modern Java IDEs include built-in support for Maven.<br />
        <br />
        To get started in Eclipse, save the sample <code>pom.xml</code> below in a new folder. Then, choose File &gt; Import &gt; Existing Maven Project and browse to the folder you created. Maven will automatically download and install the dependencies you need to get started.
        </div>

        <div class="highlighter-rouge"><div class="file">/pom.xml</div><pre><code class="xml">
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;your-group-id&lt;/groupId&gt;
  &lt;artifactId&gt;your-project-id&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;your-project-id&lt;/name&gt;
  &lt;url&gt;your-project-url&lt;/url&gt;

  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
  &lt;/properties&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.2&lt;/version&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.8&lt;/source&gt;
          &lt;target&gt;1.8&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;edu.rice.mschurr&lt;/groupId&gt;
      &lt;artifactId&gt;lightning&lt;/artifactId&gt;
      &lt;version&gt;0.0.2&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
        </code></pre></div>

        <div class="info-box">The latest version of Lightning may not always be available through Maven Central. You can download and utilize the latest version by cloning <a href="https://github.com/lightning-framework/lightning" target="_blank">lightning-framework/lightning</a> and running <code>mvn install</code> in the cloned folder. This will install the latest version locally onto your machine and allow you to use it in your projects as if it was available from Maven Central. For some IDEs (e.g. Eclipse), simply importing the downloaded Maven project folder into your IDE will be sufficient.</div>

        <p>Next, you'll want to set up logging by adding a <code>logback.xml</code> file. See <a href="#logging">Logging</a> for an example logback file.</p>

        <p>Next, you'll want to write a launcher for your application. You will run this launcher class in order to start the built-in web server.</p>

        <div class="highlighter-rouge"><div class="file">/src/main/java/myapp/AppLauncher.java</div><pre><code class="java">
package myapp;
import lightning.Lightning;
import lightning.config.Config;

public final class AppLauncher {
  public static void main(String[] args) throws Exception {
    // Lightning requires some configuration information.
    // In particular, we must tell it what package(s) should be scanned for routes.
    Config config = new Config();
    config.scanPrefixes = ImmutableList.of("myapp.controllers");
    config.server.hmacKey = "SOMETHING LONG AND RANDOM!";

    // Launch the server and block the thread until the server exits.
    (new LightningServer(config)).start().join();
  }
}
        </code></pre></div>

        <p>Next, let's add a controller that displays a simple hello world page.</p>

        <div class="highlighter-rouge"><div class="file">/src/main/java/myapp/controllers/HomeController.java</div><pre><code class="java">
package myapp.controllers;
import lightning.ann.*;
import static lightning.enums.HTTPMethod.*;
import static lightning.server.Context.*;

@Controller
public final class HomeController {
  @Route(path="/", methods={GET})
  public void handleHomePage() throws Exception {
    response().write("Hello World!");
  }
}
        </code></pre></div>

        <p>To view your application, run <code>AppLauncher</code> and navigate to <a href="http://localhost/" target="_blank">http://localhost/</a> in the web browser of your choice.</p>

        <div class="info-box">Lightning contains many additional configuration options. For example, you can set the <code>server.port</code> property to change the port that the built-in server binds to. See <a href="#config">here</a> for a complete list of available options. See <a href="#external">here</a> for instructions on integrating third-party databases and libraries with Lightning.</div>
        <h3>Using an SQL Database</h3>
        <p>First, you need to configure a database by modifying your launcher:</p>
        <div class="highlighter-rouge"><div class="file">/src/main/java/myapp/AppLauncher.java</div><pre><code class="java">
...
public final class AppLauncher {
  public static void main(String[] args) throws Exception {
    ...
    // Add a MySQL database:
    config.db.host = "localhost";
    config.db.port = 3306;
    config.db.user = "root";
    config.db.pass = "root";
    config.db.name = "lightning";
    ...
  }
}
        </code></pre></div>
        <p>You can now issue queries in your controllers. Let's create an example table and add some data:</p>
        <div class="highlighter-rouge"><div class="file">Schema (SQL)</div><pre><code class="sql">
CREATE TABLE tinyurls (
  code varchar(255) not null,
  url mediumtext not null,
  user_id int(64) unsigned not null,
  last_updated int(64) not null,
  last_clicked int(64) not null default 0,
  click_count int(64) not null default 0,
  PRIMARY KEY(code),
  FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE
) CHARACTER SET utf8 COLLATE utf8_general_ci;

INSERT INTO tinyurls (code, url, user_id, last_updated, last_clicked, click_count)
    VALUES ('facebook', 'http://www.facebook.com/', 0, 0, 0, 0);

INSERT INTO tinyurls (code, url, user_id, last_updated, last_clicked, click_count)
    VALUES ('google', 'http://www.google.com/', 0, 0, 0, 0);
        </code></pre></div>
        <p>To retrieve this data in your app and format it as JSON you can issue a query:</p>
        <div class="highlighter-rouge"><div class="file">/src/main/java/myapp/controllers/ListUrlsController.java</div><pre><code class="java">
package myapp.controllers;
import lightning.ann.*;
import static lightning.enums.HTTPMethod.*;
import static lightning.server.Context.*;
import java.util.*;

@Controller
public final class ListUrlsController {
  @Route(path="/urls/json", methods={GET})
  @Json // Returned object should be JSONified and written to response.
  public Object handleListUrlsJson() throws Exception {
    return fetchUrls();
  }

  public List&lt;Map&lt;String, Object&gt;&gt; fetchUrls() throws Exception {
    List&lt;Map&lt;String, Object&gt;&gt; rows = new ArrayList&lt;&gt;();

    try (NamedPreparedStatement query = db().prepare("SELECT * FROM tinyurls;")) {
      try (ResultSet result = query.executeQuery()) {
        while (result.next()) {
          Map&lt;String, Object&gt; row = new HashMap&lt;&gt;();
          row.put("code", result.getString("code"));
          row.put("url", result.getString("url"));
          rows.add(row);
        }
      }
    }

    return rows;
  }
}
        </code></pre></div>
        <p>For more information, see the <a href="#sql">Lightning SQL Documentation</a>.</p>
        <h3>Rendering Templates</h3>
        <p>We can extend the above controller to display the URLs as HTML instead of JSON by using a template.</p>
        <p>First, we need to configure templates by modifying the launcher:</p>
        <div class="highlighter-rouge"><div class="file">/src/main/java/myapp/AppLauncher.java</div><pre><code class="java">
...
public final class AppLauncher {
  public static void main(String[] args) throws Exception {
    ...
    config.server.templateFilesPath = "myapp/templates";
    ...
  }
}
        </code></pre></div>
        <p>Second, we need to modify the controller to render the template:</p>
        <div class="highlighter-rouge"><div class="file">/src/main/java/myapp/controllers/ListUrlsController.java</div><pre><code class="java">
...
public final class ListUrlsController {
...
  @Route(path="/urls", methods={GET})
  @Template("urls.ftl")
  public Object handleListUrls() throws Exception {
    // Return the view model for urls.ftl.
    return ImmutableMap.of("urls", fetchUrls());
  }
...
}
        </code></pre></div>
        <p>Third, we need to write the template:</p>
        <div class="highlighter-rouge"><div class="file">/src/main/resources/myapp/templates/urls.ftl</div><pre><code class="html">
&lt;#escape x as x?html&gt;
  &lt;#list urls as item&gt;
    ${item.code} - ${item.url}&lt;br /&gt;
  &lt;/#list&gt;
&lt;/#escape&gt;
        </code></pre></div>
        <p>For more information, see the <a href="#templates">Lightning Templates Documentation</a>. You may also find the <a href="http://freemarker.org/" target="_blank">FreeMarker Documentation</a> useful. If you would prefer to use a template language other than FreeMarker, you may <a href="#config">configure</a> one.</p>
        <h3>Static Files</h3>
        <p>To serve static files, configure a root directory by modifying your launcher:</p>
        <div class="highlighter-rouge"><div class="file">/src/main/java/myapp/AppLauncher.java</div><pre><code class="java">
...
public final class AppLauncher {
  public static void main(String[] args) throws Exception {
    ...
    // Specify a path in your project class path.
    // Prefer using a relative path so that you can package to a JAR.
    config.server.staticFilesPath = "myapp/static";
    ...
  }
}
        </code></pre></div>
        <p>All static files will be served on their paths relative to the root directory you specify. For example, with the above configuration, you can place an image at <code>/src/main/resources/myapp/static/image.jpg</code> and it will be served on <a href="http://localhost/image.jpg">http://localhost/image.jpg</a>.</p>

        <p>In production, Lightning will attempt to serve these files optimally (using memory-mapped buffers, in-memory caching, and HTTP caching). You may <a href="#config">configure</a> the behavior of these caches if you wish. In debug mode, all caching will be disabled to ensure that you receive the newest version of these files each time you refresh the page. In both modes, Lightning supports HTTP range queries.</p>

        <h3>Handling Forms</h3>
        <p>Consider the following web form for adding a new short URL:</p>
        <div class="highlighter-rouge"><div class="file">Form</div><pre><code class="html">
&lt;form action="http://localhost/urls/add" method="POST"&gt;
  Code: &lt;input type="text" name="code" /&gt;
  URL: &lt;input type="text" name="url" /&gt;
  &lt;input type="submit" value="Add URL" /&gt;
&lt;/form&gt;
        </code></pre></div>
        <p>You might write a handler for this form as follows:</p>
        <div class="highlighter-rouge"><div class="file">/src/main/java/myapp/controllers/AddUrlController.java</div><pre><code class="java">
package myapp.controllers;
import lightning.ann.*;
import lightning.enums.HTTPStatus;
import static lightning.enums.HTTPMethod.*;
import static lightning.server.Context.*;
...

public final class AddUrlController {
  @Route(path="/urls/add", methods={POST})
  public void handleAddUrl() throws Exception {
    validate("code").isLongerThan(2)
                    .isShorterThan(6)
                    .isAlphaNumericDashUnderscore();
    validate("url").isURL();

    if (passesValidation()) {
      db().transaction(() -> {
        try (NamedPreparedStatement q1 =
                 db().prepare("SELECT * FROM tinyurls WHERE code = :code;")) {
          q1.setString("code", queryParam("code").stringValue());
          try (ResultSet r1 = q1.executeQuery()) {
            // Abort and show a 400 page if a row exists.
            badRequestIf(r1.next(), "Provided code already in use.");
          }
        }

        db().prepareInsert("tinyurls", ImmutableMap.of(
          "url", queryParam("url").stringValue(),
          "code", queryParam("code").stringValue(),
          "user_id", 0,
          "last_updated", Time.now()
        )).executeUpdateAndClose();
      });

      response().write("Your URL has been saved.");
    } else {
      // Abort and show a 400 page.
      badRequest(validator().getErrorsAsString());
    }
  }
}
        </code></pre></div>

        <h3>Speeding Up Development</h3>
        <p>You should enable debug mode to speed up your development process. You can do this by modifying your launcher:</p>

        <div class="highlighter-rouge"><div class="file">/src/main/java/myapp/AppLauncher.java</div><pre><code class="java">
public final class AppLauncher {
  public static void main(String[] args) throws Exception {
    ...
    config.enableDebugMode = true;
    config.autoReloadPrefixes = config.scanPrefixes;
    ...
  }
}
        </code></pre></div>

        <p>After enabling debug mode, you should find:</p>
        <ul>
          <li>Your code changes take immediate effect when you refresh the page in your browser without the need to restart the server (save-and-refresh development). In order for this feature to work, you'll need to make sure your IDE is configured to recompile automatically when you save.</li>
          <li>You will see in-browser stack traces when one of your route handlers throws an exception. In production, you would simply see a generic 500 Internal Server Error page which reveals no information about the error.</li>
          <li>You can see a route overview on <a href="http://localhost/~lightning/routes">http://localhost/~lightning/routes</a>.</li>
        </ul>


        <a href="images/debugscreen.png" target="_blank" class="image-frame">
          <img src="images/debugscreen.png" />
          <span>An in-browser debug stack trace.</span>
        </a>
        <a href="images/routeoverview.png" target="_blank" class="image-frame">
          <img src="images/routeoverview.png" />
          <span>The in-browser route overview.</span>
        </a>

        <p>For more details, see <a href="#debug">debug mode</a>.</p>

        <h3>Users and Authentication</h3>
        <p>You may provide your own third-party system for managing users, sessions, and authentication (see <a href="#external">Using External Tools</a>), or, for convenience, you may choose to utilize the ones provided by Lightning (see <a href="#auth">Authentication</a>).</p>



      </section>

      <section>
        <a name="config"></a>
        <h2>Configuration</h2>
        <p>Lightning is configured primarily by building an instance of <code>lightning.config.Config</code> and passing that instance to <code>Lightning::launch</code>. You can create the needed <code>Config</code> instance any way you like! You can build it in code, parse it from a file, parse it from command-line flags, or any combination thereof. Our goal is to provide maximum customizability and a production-ready web server. As such, we have included a huge number of configuration options with sensible defaults to let you get started quickly and scale when you need to. At this time, <code>scanPrefixes</code> and <code>server.hmacKey</code> are the only mandatory configuration options. The server will fail to start and display an error in cases where your configuration is invalid.</p>

        <div class="info-box">A subset of configuration options are documented here. The complete documentation for configuration options can be found in the source code of <code><a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/config/Config.java" target="_blank">Config.java</a></code>.</div>
        <p>A few components of Lightning are configured via <a href="#deps_injection">dependency injection</a>. In particular, the drivers for sessions, users, groups, auth, templates, json, and the cache are configured this way (see below).</p>
        <p>Information about configuring various components of the framework follows.</p>

        <h3>Debug Mode</h3>
        <p>To enable debug mode, set <code>enableDebugMode</code> to <code>true</code>.</p>
        <p>To enable automatic code reloading in debug mode, set <code>autoReloadPrefixes</code> to a list of Java package prefixes whose code can be <strong>safely</strong> reloaded while the server is running. See <a href="#debug">Debug Mode</a> for more info.</p>

        <h3>Cookies</h3>
        <p>To enable the <a href="#cookies">Cookies API</a>, set <code>server.hmacKey</code> to a secret private key.</p>

        <h3>Static Files</h3>
        <p>To enable static file serving, set <code>server.staticFilesPath</code> to a path relative to <code>${project}/src/main/resources</code>. File paths will be mapped directly to web server paths (for example, <code>image.jpg</code> in the folder you specify will be served on <code>/image.jpg</code>).</p>
        <p>Additional configuration options are available to control the performance of static file caching; see <code>Config.java</code> for more information.</p>
        <h3>SSL</h3>
        <p>To use SSL, you must place your certificate in a Java Key Store (JKS) and then set the <code>ssl</code> options. You can find information on how to place your certificates (.pem/.crt) into a Java Key Store (.jks) in the <a href="http://www.eclipse.org/jetty/documentation/current/configuring-ssl.html" target="_blank">Jetty Documentation: Configuring SSL</a>.</p>
        <h3>HTTP/2</h3>
        <p>To enable HTTP/2, set <code>server.enableHttp2</code> to <code>true</code>. <strong>Be sure to read the documentation on this configuration option!</strong> You may need to use a custom JVM boot path to use HTTP/2. HTTP/2 requires you to enable SSL.</p>
        <h3>Multipart Support</h3>
        <p>To enable HTTP multipart support, set <code>server.multipartEnabled</code> to <code>true</code>. <code>server</code> includes additional multipart-related options that you may wish to configure (e.g. to limit maximum request size). You might want to upload the temporary files location and thresholds at which parts are flushed to disk.</p>
        <h3>Template Drivers</h3>
        <p>To utilize templates, set <code>server.templateFilesPath</code> to a path relative to <code>${project}/src/main/resources</code>.</p>
        <p>You may bind a dependency injection for <code>lightning.templates.TemplateEngine</code> to utilize a custom template engine. By default, FreeMarker is used.</p>
        <h3>JSON Drivers</h3>
        <p>You may bind a dependency injection for <code>lightning.json.JsonService</code> to utilize a custom JSON engine. By default, Google's <code>gson</code> library is used.</p>
        <h3>Cache Drivers</h3>
        <p>You must bind a dependency injection form <code>lightning.cache.CacheDriver</code> to utilize the <a href="#caches">Cache APIs</a>. By default, the Cache APIs will be unavailable.</p>
        <h3>Mail</h3>
        <p>Configure the <code>mail</code> property to set up access to an SMTP server or enable the logging mail driver in order to use the <a href="#email">Mail APIs</a>.</p>
        <h3>MySQL</h3>
        <p>Configure the <code>db</code> property to set up access to a MySQL database.</p>

        <h3>Session Drivers</h3>
        <p>No custom configuration is available at this time. By default, an SQL driver is used on the database configured in the <code>db</code> property. Make sure you have installed the <a href="https://github.com/lightning-framework/lightning/tree/master/src/main/resources/lightning/schema" target="_blank">schema</a> needed.</p>
        <h3>User Drivers</h3>
        <p>No custom configuration is available at this time. By default, an SQL driver is used on the database configured in the <code>db</code> property. Make sure you have installed the <a href="https://github.com/lightning-framework/lightning/tree/master/src/main/resources/lightning/schema" target="_blank">schema</a> needed.</p>
        <h3>Group Drivers</h3>
        <p>No custom configuration is available at this time. By default, an SQL driver is used on the database configured in the <code>db</code> property. Make sure you have installed the <a href="https://github.com/lightning-framework/lightning/tree/master/src/main/resources/lightning/schema" target="_blank">schema</a> needed.</p>
        <h3>Auth Drivers</h3>
        <p>No custom configuration is available at this time. By default, an SQL driver is used on the database configured in the <code>db</code> property. Make sure you have installed the <a href="https://github.com/lightning-framework/lightning/tree/master/src/main/resources/lightning/schema" target="_blank">schema</a> needed.</p>
        <h3>Custom Options</h3>
        <p>You can extend <code>lightning.config.Config</code> if you wish to add custom configuration options specific to your application.</p>

        <div class="highlighter-rouge"><div class="file">/src/main/java/myapp/config/MyAppConfig.java</div><pre><code class="java">
package myapp.config;
import lightning.config.Config;

public final class MyAppConfig extends Config {
  public int myOption;
  public String myOtherOption = "DEFAULT";
}
        </code></pre></div>

        <p>You will still be able to pass your subclass to <code>Lightning::launch</code> thanks to the magic of polymorphism. If you wish to access your custom configuration options in your controllers, you should set up <a href="#deps_injection">dependency injection</a> for your custom configuration type:</p>
        <div class="highlighter-rouge"><pre><code class="java">
injector.bindClassToInstance(MyAppConfig.class, config);
        </code></pre></div>
      </section>

      <section>
        <a name="debug"></a>
        <h2>Debug Mode</h2>
        <p>To enable debug mode, <a href="#config">configure</a> <code>enableDebugMode</code> to <code>true</code> in your application launcher.</p>
        <p>There are cases where you may wish to change the behavior of your application code when debug mode is enabled (for example, to disable caching done by your code). You can check (in your code) if debug mode is enabled by invoking <code>context().isDebug()</code> on <code>lightning.server.Context</code>.</p>
        <p>Debug mode <strong><em>should never</em></strong> be enabled in production deployments as it exposes system internals and severely degrades scalability since it disables most caching.</p>
        <p>In order to use debug mode, you must:</p>
        <ul>
          <li>Configure <code>projectRootPath</code> to point to your project's root folder (where <code>pom.xml</code> is)</li>
          <li>Follow Maven directory structure conventions (place code in <code>src/main/java</code> and resources in <code>src/main/resources</code>)</li>
        </ul>
        <p>If you enable debug mode, the following features will be activated:</p>
        <ul>
          <li>Enables automatic hot reloading of all Java classes defined within a package specified in your configured <code>autoReloadPrefixes</code> by using a custom class loader. This includes all routes, exception handlers, filters, etc. defined within those packages. In order for this feature to work, you will want to configure your IDE to automatically recompile on save. <strong>It is important to understand that not all code can be safely reloaded!</strong> You should make sure that you understand the limitations of <a href="https://www.toptal.com/java/java-wizardry-101-a-guide-to-java-class-reloading" target="_blank">Java Class Loading</a> (outlined below). In particular, types for which you have configured <a href="#deps_injection">dependency injection</a> and any code in <code>lightning.*</code> or any of its dependencies may not be reloaded safely.</li>
          <li>Enables displaying exception stack traces and debug information in-browser. This debug page will show <em>instead of</em> the generic 500 Internal Server error page generated by the framework that you would see in production (with debug mode disabled). You may add additional search paths for code snippets by specifying <code>codeSearchPaths</code>. Keep in mind that finding code snippets is an imperfect art (there's a decent amount of guess work involved since the compiled Java byte code available at runtime does not contain all of the information available in the source code).</li>
          <li>Enables displaying template errors in-browser</li>
          <li>Disables all caching of static files (both server-side and client-side)</li>
          <li>Disables all caching of template files</li>
          <li>Enables an interactive in-browser route overview on the configured <code>debugRouteMapPath</code></li>
        </ul>
        <p>Please keep in mind that errors are <em>always</em> <a href="#logging">logged</a> regardless of whether or not debug mode is enabled.</p>

        <p>You may use debug mode when deployed to a JAR. You will not be able to reload code when deployed to a JAR, but you will still be able to get stack traces (though note the code snippets will be absent unless you correctly configure <code>projectRootPath</code> or package the source files into the JAR).</p>

        <a href="images/debugscreen.png" target="_blank" class="image-frame">
          <img src="images/debugscreen.png" />
          <span>An in-browser debug stack trace.</span>
        </a>
        <a href="images/routeoverview.png" target="_blank" class="image-frame">
          <img src="images/routeoverview.png" />
          <span>The in-browser route overview.</span>
        </a>

        <h3>Code Hot-Swapping</h3>

        <p>The ability to reload code changes without restarting the web server is one of Lightning's most powerful features. This feature brings the save-and-refresh style development that has made languages like PHP and Python popular for web development to Java. In order to use this feature, you will need to enable debug mode and configure <code>autoReloadPrefixes</code>. To make best use of this feature, you will want to use an IDE or build process that automatically recompiles Java class files when you save code changes. Eclipse and IntelliJ both support this functionality.</p>

        <p><code>autoReloadPrefixes</code> specifies a list of package prefixes. Java code in packages beginning with these prefixes is assumed to be <em>safe to reload</em> on each incoming request. Java code in packages not beginning with these prefixes will not be reloaded on each incoming request - instead, a version of the code in these packages captured near JVM start-up time will be used for all requests.</p>

        <h3>Understanding Class Loading and Limitations</h3>

        <p>Each <code>.java</code> code file is compiled into one or more <code>.class</code> files (one per Java class). Each <code>.class</code> file contains the metadata and byte code for a single Java class that can be loaded and executed by a Java Virtual Machine (JVM).<p>

        <p>Each class is loaded into memory by the JVM through a <code>java.lang.ClassLoader</code> the first time that it is referenced by byte code execution on the JVM. The code for a class is fixed (snapshotted) at the time it is loaded into memory by a class loader. Once created, these snapshots cannot be changed. Each <code>java.lang.Class</code> maintains a reference to the <code>ClassLoader</code> that loaded it into memory (e.g. <code>MyClass.class.getClassLoader()</code>). The default <code>ClassLoader</code> (<code>ClassLoader.getSystemClassLoader()</code>) in the JVM simply looks in the environment class path (specified in command line via <code>java -cp</code>) for the corresponding <code>.class</code> file on disk and loads it into memory. Static initialization of a class (static variables and <code>static { ... }</code> blocks) occurs at the time the class is loaded into memory.</p>

        <p>It is possible to have more than one <code>ClassLoader</code> active in the JVM at a time. In fact, by creating a new <code>ClassLoader</code> instance after making code changes, we can obtain a newer (more recent) snapshot of the code for a class by invoking <code>loadClass</code> manually on the new <code>ClassLoader</code> instance.</p>

        <p>To fully understand class loading, it is critical to understand a few things:</p>
        <ul>
          <li>For each <code>ClassLoader</code>, subsequent calls to <code>loadClass</code> with the same class name must return the same <code>Class</code> snapshot (instance) that previous calls returned</li>
          <li>For each <code>ClassLoader</code>, when <code>loadClass</code> is invoked with a class name that has not yet been observed by that <code>ClassLoader</code>, the <code>ClassLoader</code> may either load a new snapshot of the <code>Class</code> from disk or delegate to a snapshot (instance) of the <code>Class</code> created by a different <code>ClassLoader</code>.</li>
          <li><code>ClassLoader</code>s do not replace code that was previously loaded, but may instead elect to create a new snapshot (instance) of the same <code>Class</code>. Thus, there may exist many distinct, type-incompatible <code>Class</code>es with the same canonical name loaded into the JVM at the same time (up to one instance per <code>ClassLoader</code>).</li>
          <li>When the JVM encounters a reference to a class that has not yet been loaded <em>by the same class loader that was used to load the code containing the reference</em>, <code>loadClass</code> is invoked on that class loader to obtain a snapshot of the reqiured class (possibly from disk) before continuing execution.</li>
        </ul>

        <p>This is how Lightning implements automatic code reloading - not through replacement, by loading and executing newer snapshots of the code. For each incoming request, Lightning creates a new class loader which acquires new snapshots for <em>only</em> the classes contained in <code>autoReloadPrefixes</code>.</p>

        <p>For the classes not contained in <code>autoReloadPrefixes</code>, the new class loader <em>delegates</em> to <code>loadClass</code> on the system class loader. This means that <em>at most one snapshot</em> will exist for classes designated as non-reloadable. Further, static initialization will occur <em>at most once</em> for those classes. In other words, static state <em>will</em> persist through code reloads on classes designated as non-reloadable but <em>will not</em> persist through code reloads on classes designated as reloadable.</p>

        <p>In practice, this makes it acceptable for reloadable classes to reference non-reloadable classes as it is assumed that the code for non-reloadable classes will not change during the lifetime of the JVM. On the other hand, it is not recommended for non-reloadable classes to reference reloadable classes since that reference will be fixed to the snapshot captured by the system class loader - a snapshot that will not be updated until the JVM is restarted.</p>

        <p>Our recommendation is to enable code hot-swapping for all of your application code except:</p>
        <ul>
          <li>The class containing your <code>main</code> method (the launcher)</li>
          <li>Any classes which are dependency injected</li>
          <li>Any classes which are referenced by non-reloadable code</li>
          <li>Any classes defined by Lightning (<code>lightning.*</code>) or its dependencies</li>
          <li>Any classes which cannot be modified during runtime (e.g. Maven dependencies)</li>
        </ul>

        <p>NOTE: Reloading dependency-injectable classes is problematic because, for example, <code>InjectorModule::bindClassToInstance</code> called by your launcher binds the <code>Class</code> object loaded by the system class loader to an instance of that class with the code snapshot created by the system class loader. If that class is marked as reloadable, then, when your reloadable code wishes to inject an instance of that class, the reloadable code is not referencing the version of the class loaded by the system class loader, but a version loaded by a more recently created class loader. Even though that type and the type for which you installed the dependency injection binding have the same canonical name, the JVM treats them as distinct types referring to different snapshots of the code. Therefore, they are not type compatible. Consequently, Lightning's dependency injector will be unable to resolve an object for that parameter and will throw an exception at runtime.</p>

      </section>

      <section>
        <a name="logging"></a>
        <h2>Logging</h2>
        <p>Lightning uses <a href="http://www.slf4j.org/" target="_blank">SLF4J</a> for logging implemented by <a href="http://logback.qos.ch/" target="_blank">logback</a>.</p>
        <p>We recommend using logback to configure SLF4J to display logs in your console. A simple way to achieve this is adding a <code>logback.xml</code> file to your project classpath. We recommend setting the logging level to <code>INFO</code> for lightning classes and <code>DEBUG</code> for your classes.</p>
        <div class="highlighter-rouge"><div class="file">/src/main/resources/logback.xml</div><pre><code class="xml">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
  &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{5} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;
  &lt;logger name=&quot;myapp&quot; level=&quot;DEBUG&quot; /&gt;
  &lt;logger name=&quot;lightning&quot; level=&quot;INFO&quot; /&gt;
  &lt;root level=&quot;WARN&quot;&gt;
    &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;
        </code></pre></div>
      </section>

      <section>
        <a name="deps_injection"></a>
        <h2>Dependency Injection</h2>
        <p>Lightning allows you to inject custom dependencies into most areas of the framework. This includes exception handlers, route handlers, web sockets, filters, initializers, finalizers, controller constructors - almost any method or constructor that is invoked by the framework.</p>
        <p>To configure dependency injection, you must build an <code>InjectorModule</code> and pass the module to <code>Lightning::launch</code> in your launcher.</p>
        <p>An <code>InjectorModule</code> allows you to specifies objects that you would like to be injectable. You may specify injections either by (a) their type, (b) the presence of a custom annotation on a parameter, or (c) the presence of a <code>@Inject(name)</code> annotation on the parameter. An example of configuring each of the types of injection is below:</p>
        <div class="highlighter-rouge"><div class="file">AppLauncher.java</div><pre><code class="java">
import lightning.config.Config;
import lightning.inject.InjectorModule;
import lightning.Lightning;

class AppLauncher {
  public static void main(String[] args) throws Exception {
    Config config = ...;
    InjectorModule injector = new InjectorModule();
    injector.bindClassToInstance(MyDependency.class, new MyDependency());
    injector.bindNameToInstance("MyDependency", new MyDependency());
    injector.bindAnnotationToInstance(MyAnnotation.class, new MyDependency());
    (new LightningServer(config, injector)).start().join();
  }
}
        </code></pre></div>
        <p>You may utilize the injected dependencies by inserting them as arguments to any injectable constructor or method. An example is below:</p>
        <div class="highlighter-rouge"><div class="file">MyController.java</div><pre><code class="java">
import lightning.ann.*;

@Controller
public final class MyController {
  @Route(path="/a", method={GET})
  public void handleA(MyDependency dep) throws Exception {
    // dep is the instance bound via bindClassToInstance.
  }

  @Route(path="/b", method={GET})
  public void handleB(@MyAnnotation MyDependency dep) throws Exception {
    // dep is the instance bound via bindAnnotationToInstance.
  }

  @Route(path="/c", method={GET})
  public void handleC(@Inject("MyDependency") MyDependency dep) throws Exception {
    // dep is the instance bound via bindNameToInstance.
  }
}
        </code></pre></div>
        <p>In addition to custom dependency injection, Lightning will automatically configure dependency injection for global framework types (like <code>Config</code>) and request-specific types where applicable (like <code>Request</code> and <code>Response</code>).</p>
        <p>It is not possible to inject custom request-specific objects; only global objects can be injected at this time. If you need request-specific objects, inject a thread-safe factory or <code>ThreadLocal</code> factory that produces those objects.</p>
        <p>There's no limit to how many injectable arguments a method can have so long as each argument can be resolved by the dependency injector. The framework will throw an exception if it encounters a method for which it cannot resolve all parameters.</p>
        <p>It is not possible to dependency inject instances of classes whose code is flagged to automatically reload while running in <a href="#debug">debug mode</a>.</p>
        <h3>Framework-Provided Injectable Types</h3>
        <p>The follow global objects are available for dependency injection:</p>
        <table class="grid">
          <tr><td><code>lightning.config.Config</code> (equivalent to invoking <code>config()</code>)</td></tr>
          <tr><td><code>lightning.mail.Mailer</code> (equivalent to invoking <code>mail()</code>)</td></tr>
          <tr><td><code>lightning.templates.TemplateEngine</code></td></tr>
          <tr><td><code>lightning.cache.Cache</code> (equivalent to invoking <code>cache()</code>)</td></tr>
          <tr><td><code>lightning.json.JsonService</code></td></tr>
          <tr><td><code>lightning.db.MySQLDatabaseProvider</code> (connection pool, only if <a href="#config">configured</a>)</td></tr>
          <tr><td>Any types you install in the <code>InjectorModule</code> passed to Lightning by your launcher</td>
        </table>
        <p>The following request-specific objects are available for dependency injection (where applicable):</p>
        <table class="grid">
          <tr><td><code>lightning.http.Request</code>  (equivalent to invoking <code>request()</code>)</td></tr>
          <tr><td><code>lightning.http.Response</code> (equivalent to invoking <code>response()</code>)</td></tr>
          <tr><td><code>lightning.sessions.Session</code> (equivalent to invoking <code>session()</code>)</td></tr>
          <tr><td><code>lightning.mvc.Validator</code> (equivalent to invoking <code>validator()</code>)</td></tr>
          <tr><td><code>lightning.mvc.URLGenerator</code> (equivalent to invoking <code>url()</code>)</td></tr>
          <tr><td><code>lightning.groups.Groups</code> (equivalent to invoking <code>groups()</code>)</td></tr>
          <tr><td><code>lightning.users.Users</code> (equivalent to invoking <code>users()</code>)</td></tr>
          <tr><td><code>lightning.users.User</code> (equivalent to invoking <code>user()</code>)</td></tr>
          <tr><td><code>lightning.db.MySQLDatabase</code> (equivalent to invoking <code>db()</code>)</td></tr>
          <tr><td><code>lightning.mvc.HandlerContext</code> (instance version of <code>lightning.server.Context</code>)</td></tr>
          <tr><td><code>lightning.websockets.WebSocketHandlerContext</code> (instance version of <code>lightning.websockets.WebSocketContext</code>)</td></tr>
          <tr><td><code>javax.servlet.http.HttpServletRequest</code> (equivalent to invoking <code>request().raw()</code>)</td></tr>
          <tr><td><code>javax.servlet.http.HttpServletResponse</code> (equivalent to invoking <code>response().raw()</code>)</td></tr>
          <tr><td><code>lightning.cache.Cache</code>  (equivalent to invoking <code>cache()</code>)</td></tr>
          <tr><td><code>org.eclipse.jetty.websocket.servlet.ServletUpgradeRequest</code> (only in <a href="#websockets">Web Sockets</a>)</td></tr>
          <tr><td><code>org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse</code> (only in <a href="#websockets">Web Sockets</a>)</td></tr>
        </table>
        <h3>Query/Route Parameter Injection</h3>
        <p>You may annotate a parameter with <code>@QParam(name)</code> to inject the value of the query parameter with the given name. Similarly, you may annotate a parameter with <code>@RParam(name)</code> to inject the value of the route parameter with the given name. The annotated parameter must have type <code><a href="#parameters">Param</a></code>, <code>String</code>, <code>int/Integer</code>, <code>long/Long</code>, <code>double/Double</code>, or <code>float/Float</code>. The framework will automatically attempt to convert the provided parameter to the given type. If a conversion cannot be performed or if the query/route parameter is not present, a <code>BadRequestException</code> will be thrown.</p>
      </section>

      <section>
        <a name="lifecycle"></a>
        <h2>Life Cycle, Threading, &amp; Context</h2>
        <p>Lightning uses a thread-per-request model. For each incoming HTTP request or web socket event, a thread is allocated from the server thread pool to service that request/event to completion.</p>
        <p>A HTTP request will be allocated only a single thread throughout it's lifetime. Thus, you may safely use the static methods defined on <code>lightning.server.Context</code> to access resources allocated to the incoming request in a thread-safe manner.</p>
        <p>The allocated thread is released back into the pool upon returning from the request or event handler, whether normally or exceptionally, after the framework has completed any neccesary finalizing actions (such as rendering a template or error page).</p>
        <p>The general life-cycle for an incoming HTTP request is:</p>
        <ol>
          <li>Allocate a thread to the request</li>
          <li>Match the request to a route</li>
          <li>Invoke any path-based before filters</li>
          <li>Allocate a new controller instance</li>
          <li>Invoke initializers on the controller</li>
          <li>Invoke the matched controller method</li>
          <li>Invoke any finalizers on the controller</li>
          <li>Finalize the response and clean-up resources</li>
          <li>Release the thread back into the pool</li>
        </ol>
        <p>Invoking <code>halt()</code> is a simple way to skip to step (8) from any previous step in the process. Similarly, if an exception is thrown anywhere in the process, the framework will skip to step (8) and the finalizing action will instead be to render an error page (or invoke a <a href="#exceptions">custom exception handler</a> if installed).</p>
        <p>Please keep in mind that <a href="#async">async request handlers</a> do not follow these semantics but, instead, conform to the semantics specified by the Java Servlet API for asynchronous handlers. In particular, resources allocated to the request <em>are not</em> cleaned up upon returning from the handler, but will instead be cleaned up at a later point in time when the <code>AsyncContext</code> is closed.</p>
      </section>

      <section>
        <a name="controllers"></a>
        <h2>Controllers</h2>
        <p>A <em>controller</em> is simply a class that can handle incoming HTTP requests. All controllers must be annotated with (or have a parent annotated with) <a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/ann/Controller.java" target="_blank"><code>@Controller</code></a> and must be located within the scan prefixes specified in the <a href="#config">configuration</a> provided to Lightning.</p>
        <p>Controller classes must be declared public and may have up to one public constructor. A controller's constructor is <a href="#deps_injection">injectable.</a></p>
        <p>Controllers may have initializers (methods annotated with <a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/ann/Initializer.java" target="_blank"><code>@Initializer</code></a>), finalizers (methods annotated with <a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/ann/Finalizer.java" target="_blank"><code>@Finalizer</code></a>), and <a href="#routes">routes</a> (methods annotated with <a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/ann/Route.java" target="_blank"><code>@Route</code></a>). Initializers, finalizers, and routes are all <a href="#deps_injection">injectable</a>.</p>
        <p>When an incoming request matches a route specified on a controller, a new instance of the controller class is allocated. All initializers are invoked by the controller, followed by the matched route method, followed by all finalizers.</p>
        <p>Initializers and finalizers are inherited by child classes. If a controller has multiple initializers/finalizers, the order in which they execute is undefined.</p>
        <p>Initializers must be public, must return void, and may throw exceptions. If an initializer throws an exception, further processing of the request is halted (including any unexecuted initializers and the matched route - finalizers still execute).</p>
        <p>Finalizers must be public, must return void, and may throw exceptions. All finalizers will always execute. Finalizers serve the purpose of destructors and may be reliably used for resource clean-up. Finalizer exceptions are suppressed and will only be visible via the <a href="#logging">SLF4J log</a>.</p>
        <div class="highlighter-rouge"><div class="file">MyController.java</div><pre><code class="java">
import lightning.ann.*;
import static lightning.enums.HTTPMethod.*;
import static lightning.server.Context.*;

@Controller
public class MyController {
  @Initializer
  public void init() {
    // Save any references needed via dependency injection.
  }

  @Finalizer
  public void finalize() {
    // Clean up any allocated resources.
  }

  @Route(path="/a", methods={GET})
  public void handleRouteA() throws Exception {
    response().write("A");
  }

  @Route(path="/b", methods={GET})
  public void handleRouteB() throws Exception {
    response().write("B");
  }
}
        </code></pre></div>

      </section>

      <section>
        <a name="routing"></a>
        <h2>Routing</h2>
        <p>Pre-Requisite Article: <em><a href="#controllers">Controllers</a></em></p>
        <p>A <em>route</em> specifies particular code that should execute when the path and method of an incoming HTTP request matches those specified by the route. In Lightning, routes are specified by annotating public instance methods on <a href="#controllers">Controllers</a> with the <a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/ann/Route.java" target="_blank"><code>@Route</code></a> annotation.</p>
        <p>Routes will automatically be installed based on the presence of the annotations and can safely be automatically reloaded in debug mode. The path matcher will attempt to match paths to static files before trying to match routes.</p>
        <h3>Routing Path Format</h3>
        <p>Routing paths may contain <em>parameters</em> and/or <em>wildcards</em>.</p>
        <p>A parameter matches a single path segment. Parameters are indicated by prefixing a path segment with <code>:</code>. The remaining portion of the path segment after the <code>:</code> specifies the parameter's name. Paths may have zero or more parameters.</p>
        <p>A wildcard matches one or more path segments. Wildcards are indicated by setting a path segment to <code>*</code>. Wildcards may only be present in the last segment in the provided path. Thus, paths may have zero or one wildcard.</p>
        <p>Here are some valid example routing paths:</p>
        <ul>
          <li><code>/</code></li>
          <li><code>/my/path/</code></li>
          <li><code>/u/:username</code></li>
          <li><code>/r/:subreddit</code></li>
          <li><code>/t/:topic/c/:comment</code></li>
          <li><code>/account/*</code></li>
          <li><code>*</code> (matches everything)</li>
        </ul>
        <p>Wildcards and parameters for the matched route will be exposed on the <a href="#request">Request</a> object.</p>
        <h3>Routing Conflicts &amp; Resolution</h3>
        <p>Routing conflicts are allowed in cases where the set of matched paths is not entirely overlapping. For example, routes for both <code>*</code> and <code>/a/b</code> are allowed (on the same HTTP method). Routes for both <code>/:a/:b</code> and <code>/:b/:a</code> are not. The presence of conflicting routes will prevent server start-up and display an error in terminal.</p>
        <p>Routes are implemented using a bastardized version of a radix tree. Routing is <code>O(n)</code> with respect to the number of characters in the request path regardless of the number of routes installed.</p>
        <p>Routes are resolved by crawling the routing radix tree by path segments searching for a match with priority given to exact matches, then parametric matches, then wildcard matches.</p>
        <p>As a concrete example, consider a server with the following set of routes installed:</p>
        <ul>
          <li><code>/</code></li>
          <li><code>/something</code></li>
          <li><code>/*</code></li>
          <li><code>/:something</code></li>
          <li><code>/u/:something</code></li>
          <li><code>/u/*</code></li>
          <li><code>/z/:something</code></li>
        </ul>
        <p>For the above routes, the given request URLs will be matched as follows:</p>
        <table class="grid">
          <thead>
            <tr>
              <th>Request Path</th>
              <th>Route Pattern</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>/</code></td>
              <td><code>/</code></td>
            </tr>
            <tr>
              <td><code>/something</code></td>
              <td><code>/something</code></td>
            </tr>
            <tr>
              <td><code>/anything</code></td>
              <td><code>/:something</code></td>
            </tr>
            <tr>
              <td><code>/anything/more</code></td>
              <td><code>/*</code></td>
            </tr>
            <tr>
              <td><code>/u</code></td>
              <td><code>/:something</code></td>
            </tr>
            <tr>
              <td><code>/u/h</code></td>
              <td><code>/u/:something</code></td>
            </tr>
            <tr>
              <td><code>/u/h/z</code></td>
              <td><code>/u/*</code></td>
            </tr>
            <tr>
              <td><code>/z/h/u</code></td>
              <td><code>/*</code></td>
            </tr>
          </tbody>
        </table>

        <h3>Route Handlers</h3>
        <p>Route handlers must be <em>public, instance methods</em> defined on a <code><a href="#controllers">@Controller</a></code> located within the scan prefixes specified in Lightning's <a href="#config">config</a>. Route handlers must be annotated with <code>@Route</code> which specifies the path(s) and method(s) for which the handler will be invoked. A single method may be annotated with <code>@Route</code> multiple times.</p>
        <p>A route handler may return a value. If a route handler chooses to return a value, the framework will take an action using the return value:</p>
        <table class="grid">
          <thead>
            <tr>
              <th>Return Type</th>
              <th>Framework Action</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>void</code></td>
              <td>No Action.</td>
            </tr>
            <tr>
              <td><code>null</code></td>
              <td>No Action.</td>
            </tr>
            <tr>
              <td><code>String</code></td>
              <td>Given string will be written to response body as HTML.</td>
            </tr>
            <tr>
              <td><code>ModelAndView</code></td>
              <td>Given model and view will be rendered to response body as HTML.</td>
            </tr>
            <tr>
              <td><code>File</code></td>
              <td>Given file will be served as if it were a static file.</td>
            </tr>
            <tr>
              <td>Any other type</td>
              <td>
                IF THE HANDLER IS ANNOTATED WITH <code>@Json</code>:<br />
                Returned value will be JSONified and written to response<br />
                <br />
                IF THE HANDLER IS ANNOTATED WITH <code>@Template(name)</code>:<br />
                Returned value will be used as view model to render template with given name to the response<br />
                <br />
                OTHERWISE:<br />
                An exception will be thrown by the framework (by default, an internal server error).
              </td>
            </tr>
          </tbody>
        </table>
        <p>Route handlers may throw exceptions. The framework will catch any thrown exceptions and <a href="#exceptions">handle them</a>.</p>
        <p>Route handlers are <a href="#deps_injection">injectable</a> with both request-specific and global objects and therefore may accept any number of injectable arguments.</p>
        <p>During the execution of a route handler, the value of any matched parameters and wildcards will be available on the <a href="#requests"><code>request()</code></a>.</p>
      </section>

      <section>
        <a name="path_filters"></a>
        <h2>Path-Based Filters</h2>
        <p>You may specify code snippets that execute before route handlers on certain path patterns.</p>
        <p>An example path-based filter which filters unauthenticated requests follows:</p>

        <div class="highlighter-rouge"><div class="file">AccessControlFilters.java</div><pre><code class="java">
import lightning.ann.Before;
import lightning.http.AccessViolationException;
import lightning.http.NotAuthorizedException;

import static lightning.enums.FilterPriority.*;
import static lightning.enums.HTTPMethod.*;
import static lightning.server.Context.*;

public final class AccessControlFilters {
  @Before(path="/admin/*", methods={GET, POST}, priority=HIGH)
  public static void adminFilter() throws Exception {
    if (!user().hasPrivilege(Privilege.ADMIN)) {
      // AccessViolationException triggers an HTTP 403 Forbidden page
      // by default (unless you add a custom exception handler).
      throw new AccessViolationException();
    }
  }

  @Before(path="/admin/*", methods={GET, POST}, priority=HIGHEST)
  @Before(path="/account/*", methods={GET, POST}, priority=HIGHEST)
  public static void authFilter() throws Exception {
    if (!auth().isLoggedIn()) {
      // NotAuthorizedException triggers an HTTP 401 Unauthorized page
      // by default (unless you add a custom exception handler).
      throw new NotAuthorizedException();
    }
  }
}
        </code></pre></div>
        <p>Please keep in mind...</p>
        <ul>
          <li>Path-based filters must be defined on classes within the scan prefixes specified in the <a href="#config">configuration</a> provided to Lightning</li>
          <li>A filter method may be annotated with <code>@Before</code> multiple times</li>
          <li>You may control the order in which filters execute by changing the priority in the annotation. Filters with higher priority will execute first. Filters with the same priority may execute in any order.</li>
          <li>Path-based filter methods are <a href="#deps_injection">injectable</a> with both global and request-specific objects</li>
          <li>Path-based filters can safely use <code>lightning.server.Context</code></li>
          <li>Path-based filters will only execute if the given method and path also match a <a href="#routing">route</a>. They will not execute for static files or not founds.</li>
          <li>Path-based filters can take advantage of both wildcard paths and parameterized paths (same path format as <a href="#routing">routes</A>). The parameters and wildcards will be available on the <code><a href="#requests">request()</a></code> within the filter function.</li>
          <li>Filter matching is highly performant (porportional mostly to the length of the request path and the number of matched filters).</li>
          <li>Path-based filters may prevent further request processing by invoking <code>halt()</code> or throwing an exception (see <a href="#lifecycle">Life Cycle</a>).</li>
        </ul>
        <p>For more information about path-based filters, see <a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/ann/Before.java" target="_blank">@Before</a>.</p>
      </section>

      <section>
        <a name="exceptions"></a>
        <h2>Exception Handlers</h2>

        <p>You may specify code that should execute when a route handler or filter throws a <code>Throwable</code> of a given type. The exception handler will also match all subclasses of the given type for which a more specific handler is not installed. For example, installing an exception handler for <code>Throwable.class</code> will catch every exception.</p>

        <p>When writing exception handlers, please keep in mind that the framework does not buffer output unless you explicitly enable output buffering in your <a href="#config">configuration</a>. Thus, depending on how your application is written, HTTP headers and some of the request body may already have been sent to the client before an exception is thrown and the corresponding exception handler is invoked (for example, if a controller throws an exception in the middle of its execution).</p>

        <p>An exception handler is specified by annotating a public static method on a class located within the scan prefixes specified in your <a href="#config">configuration</a> with <code>@Exceptionhandler</code>. Exception handlers must return void but may accept any number of <a href="#deps_injection">injectable</a> (global and request-specific) arguments. In addition, the causing exception will be dependency-injectable. Exception handlers may throw exceptions. If an exception handler throws an exception, the default framework exception handler will be executed.</p>

        <div class="highlighter-rouge"><div class="file">ExampleExceptionHandler.java</div><pre><code class="java">
import lightning.ann.*;
import lightning.http.*;
import static lightning.server.Context.*;

// This class must be defined in the scan prefixes in your config.
public final class ExampleExceptionHandler {
  // Specify that this method performs exception handling for the given exception type
  // (and all subclasses thereof unless a more specific exception handler is installed
  // for a subclass).
  @ExceptionHandler(NotFoundException.class)
  public static void handleException(NotFoundException e) throws Exception {
    response().status(404);
    response().write("404 Not Found");
    halt();
  }
}
        </code></pre></div>
        <p>Things to keep in mind:</p>
        <ul>
          <li>Attempting to install multiple exception handlers for the same exception type will prevent server start-up</li>
          <li>Exception handlers may be used to log information or to render an error page</li>
          <li>Exception handlers may re-throw the causing exception to trigger the default exception handler</li>
          <li>Exception handlers may be used to <a href="#custom_errors">replace framework error pages</a></li>
          <li>Exceptions are always <a href="#logging">logged</a> (even if you don't install a handler)</li>
          <li>Exception handlers may use <code>lightning.server.Context</code></li>
          <li>Exception handlers <em>should</em> re-throw the exception when <a href="#debug">debug mode</a> is configured to pass the exception to the built-in exception handler which renders the in-browser stack traces (if you do not do this, you will not get stack traces for the registered exception type)</li>
        </ul>
      </section>

      <section>
        <a name="custom_errors"></a>
        <h2>Custom Error Pages</h2>
        <p>Pre-Requisite Article: <em><a href="#exceptions">Exception Handlers</a></em></p>

        <p>Lightning includes built-in exceptions that are thrown when certain errors occur and ships with default handlers for these exceptions. For example, <code>lightning.http.NotFoundException</code> is thrown whenever a request path does not match either a route/static file or when a controller directly throws a <code>NotFoundException</code>. The default exception handler for <code>NotFoundException</code> renders a generic 404 Not Found page. A full list of built-in exceptions and their default handler actions can be found below.</p>

        <p>All other exceptions (e.g. custom exceptions) are handled by a built-in exception handler for <code>Throwable.class</code> which generates a very generic 500 Internal Server Error page (in production) or shows the debug stack trace if <a href="#debug">debug mode</a> is configured.</p>

        <p>You may override the framework default error pages by adding <a href="#exceptions">exception handlers</a> for all of the built-in exceptions and a catch-all handler for <code>Throwable.class</code> that renders a generic error page.</p>

        <p><strong>Recommendation:</strong> All of your non-HTTP exception handlers should re-throw the causing exception when <a href="#debug">debug mode</a> is configured. This will pass the exception to the built-in handler for <code>Throwable.class</code> which will then render the in-browser stack trace. If you do not re-throw the exception when debug mode is enabled, you will not be able to see in-browser stack traces.</p>
        <p>The following HTTP exceptions are shipped with Lightning and render generic error pages:</p>
        <table class="grid">
          <thead>
            <tr>
              <th>Exception (<code>lightning.http</code>)</th>
              <th>HTTP Code</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>AccessViolationException</code></td>
              <td>403 Forbidden</td>
            </tr>
            <tr>
              <td><code>BadRequestException</code></td>
              <td>400 Bad Request</td>
            </tr>
            <tr>
              <td><code>MethodNotAllowedException</code></td>
              <td>405 Method Not Allowed</td>
            </tr>
            <tr>
              <td><code>NotAuthorizedException</code></td>
              <td>401 Unauthorized</td>
            </tr>
            <tr>
              <td><code>NotFoundException</code></td>
              <td>404 Not Found</td>
            </tr>
            <tr>
              <td><code>NotImplementedException</code></td>
              <td>501 Not Implemented</td>
            </tr>
          </tbody>
        </table>

        <p>An example of replacing some error pages with your own:</p>

        <div class="highlighter-rouge"><div class="file">CustomExceptionHandler.java</div><pre><code class="java">
import lightning.ann.*;
import lightning.http.*;
import static lightning.server.Context.*;

public final class CustomExceptionHandler {
  @ExceptionHandler(Throwable.class)
  public static void handleException(Throwable e) throws Exception {
    renderErrorPage(500,
                    'Internal Server Error',
                    'An error occurred servicing your request. Please try again.');
  }

  @ExceptionHandler(NotFoundException.class)
  public static void handleException(NotFoundException e) throws Exception {
    renderErrorPage(404,
                    'Not Found',
                    'The resource you requested does not exist.');
  }

  private static void renderErrorPage(int code, String title, String text) throws Exception {
    if (config().enableDebugMode) {
      throw e; // Re-throw to see stack traces.
    }

    response().status(code);
    render('http_error.ftl', // You need to make this template.
           ImmutableMap.of(
             'code': code,
             'title': title,
             'text': text
           ));
  }
}
        </code></pre></div>
      </section>

      <section>
        <a name="web_sockets"></a>
        <h2>Web Sockets</h2>
        <p>To define a web socket endpoint, you must define a class annotated with 
        <code><a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/ann/WebSocket.java" target="_blank">@WebSocket(path)</a></code> within the scan prefixes you specified in your <a href="#config">config</a>. This will cause your class to be set up as a web socket endpoint handler on the given routing path. Within that class, you may define handlers for various events. These events are:</p>
        <ul>
          <li><code>WEBSOCKET_HANDSHAKE</code> - Called upon receiving a web socket upgrade request</li>
          <li><code>WEBSOCKET_CONNECT</code> - Called after a web socket connection is established</li>
          <li><code>WEBSOCKET_CLOSE</code> - Called when a web socket connection terminates</li>
          <li><code>WEBSOCKET_ERROR</code> - Called when a web socket error occurs</li>
          <li><code>WEBSOCKET_BINARY_MESSAGE</code> - Called when a binary message is received</li>
          <li><code>WEBSOCKET_TEXT_MESSAGE</code> - Called when a text message is received</li>
        </ul>
        <p>The framework will inform you at start-up if your code is not correct (for example, if you define two handlers for the same event).</p>
        <div class="highlighter-rouge"><div class="file">MyWebSocket.java</div><pre><code class="java">
package myapp;

import lightning.ann.WebSocket;

@WebSocket(path="/path")
public class MyWebSocket {
  /* ... define your event handlers ... */
}

        </code></pre></div>

        <p>The life cycle of a web socket connection is as follows:</p>
        <ol>
          <li>The server invokes <code>WEBSOCKET_HANDSHAKE</code> upon receiving an upgrade request to determine whether or not the connection should be allowed to upgrade. You may also use this event handler to set the selected subprotocol (see <a href="https://tools.ietf.org/html/rfc6455" target="_blank">RFC 6455</a>).</li>
          <li>The server creates a new instance of your handler class for the connection.</li>
          <li>The server invokes <code>WEBSOCKET_CONNECT</code> when the connection is fully established.</li>
          <li>The server invokes <code>WEBSOCKET_TEXT_MESSAGE</code>/<code>WEBSOCKET_BINARY_MESSAGE</code> event handlers as messages are received.</li>
          <li>The server invokes <code>WEBSOCKET_CLOSE</code> when either endpoint terminates the connection.</li>
        </ol>

        <p>If at any time an error occurs (or if one of your event handlers throws an <code>Exception</code>), the <code>WEBSOCKET_ERROR</code> handler will be invoked immediately followed by the <code>WEBSOCKET_CLOSE</code> handler.</p>


        <h3>WEBSOCKET_HANDSHAKE</h3>
        <div class="highlighter-rouge"><pre><code class="java">
@OnEvent(EventType.WEBSOCKET_HANDSHAKE)
public static boolean onUpgradeRequest(...) throws Exception
        </code></pre></div>
        
        <p>This event handler is called upon receiving an upgrade request but before the upgrade response is sent. Your event handler should return <code>true</code> to accept the connection. If you throw an exception or return <code>false</code>, the upgrade request will be rejected.</p>
        
        <p>This method is dependency-injectable with both global and request-specific objects (see <a href="#deps_injection">Dependency Injection</a>). In addition to the standard types, <code>ServletUpgradeRequest</code> and <code>ServletUpgradeResponse</code> are injectable (you may use these to read negotiation parameters, perform origin validation, and set the selected subprotocol if needed). You may safely use <code>lightning.server.Context</code> methods in this event handler.</p>

        <p>If you do not include this event handler on your class, then all connections will be accepted by default.</p>

        <h3>Constructors</h3>

        <p>A web socket handler may have up to one <em>public</em> constructor. That constructor is dependency-injectable with both global and request-specific objects (see <a href="#deps_injection">Dependency Injection</a>). In addition to the standard types, <code>ServletUpgradeRequest</code> and <code>ServletUpgradeResponse</code> are injectable.</p>
        <p>You may safely use <code>lightning.server.Context</code> methods within the constructor, but <code>lightning.websockets.WebSocketContext</code> is not available as the connection has not yet been establsihed.</p>
        <p>All request-specific objects will go out of scope after you return from the constructor. You must not save any of these request-specific objects (e.g. Lightning's <code>Session</code>, <code>User</code>, <code>Request</code>, <code>MySQLDatabase</code>) as instance properties on your handler. Instead, you should extract the specific values you need and save those. For example, you might save the value of a cookie or the ID of the authenticated user.</p>
        <p>If you need to use templates, mail, json, or a database connection in your web socket handler, use <code>WebSocketHandlerContext</code> in the event handlers (more details below).</p>

        <p>If your constructor throws an exception, it will be as if your <code>WEBSOCKET_HANDSHAKE</code> method returned <code>false</code>.</p>

        <p>You should not reserve resources in your constructor as there is no guarantee that <code>WEBSOCKET_CONNECT</code> and <code>WEBSOCKET_CLOSE</code> will be executed.</p>

        <h3>WEBSOCKET_CONNECT</h3>
        <div class="highlighter-rouge"><pre><code class="java">
@OnEvent(EventType.WEBSOCKET_CONNECT)
public void onConnect(, ...) throws Exception
        </code></pre></div>

        <p>This event handler is called when a connection is fully established. It will be invoked at most once for each instance of your handler class that is created. The arguments are dependency-injectable with global object types and <code>WebSocketHandlerContext</code>. You <strong>may not</strong> use <code>lightning.server.Context</code> methods in this handler, but you may use <code>lightning.websockets.WebSocketContext</code> methods.</p>

        <h3>WEBSOCKET_CLOSE</h3>
        <div class="highlighter-rouge"><pre><code class="java">
@OnEvent(EventType.WEBSOCKET_CLOSE)
public void onClose(int statusCode, String reason, ...) throws Exception
        </code></pre></div>

        <p>This event handler is called when a connection is terminated. The first two arguments are fixed, but the remaining arguments are dependency-injectable with global object types and <code>WebSocketHandlerContext</code>. You <strong>may not</strong> use <code>lightning.server.Context</code> methods in this handler, but you may use <code>lightning.websockets.WebSocketContext</code> methods.</p>

        <p>This event handler will <em>always</em> be invoked <em>exactly once</em> for each instance of your handler class upon which <code>WEBSOCKET_CONNECT</code> was invoked, regardless of who terminated the connection or why it was terminated. It will still be called if your <code>WEBSOCKET_CONNECT</code> handler throws an exception. The status code may provide insight into why the connection was closed - see <a href="https://tools.ietf.org/html/rfc6455" target="_blank">RFC 6455</a>.</p>

        <h3>WEBSOCKET_ERROR</h3>
        <div class="highlighter-rouge"><pre><code class="java">
@OnEvent(EventType.WEBSOCKET_ERROR)
public void onError(Throwable error, ...) throws Exception
        </code></pre></div>

        <p>This event handler is called when one of your other event handlers throws an exception, or when something goes wrong internally within the web socket implementation. The first argument is fixed, but the remaining arguments are dependency-injectable with global object types and <code>WebSocketHandlerContext</code>. You <strong>may not</strong> use <code>lightning.server.Context</code> methods in this handler, but you may use <code>lightning.websockets.WebSocketContext</code> methods.</p>
        <p>You may use the handler to log the error if you wish, but the connection should be considered terminated if this event handler is invoked - <code>WEBSOCKET_CLOSE</code> will always be invoked afterwards.</p>

        <p>If you do not define this event handler on your class (recommended), the occurence of an error will simply log the error. See <a href="#logging">logging</a> for more information.</p>

        <h3>WEBSOCKET_TEXT_MESSAGE</h3>
        <div class="highlighter-rouge"><pre><code class="java">
@OnEvent(EventType.WEBSOCKET_TEXT_MESSAGE)
public void onTextMessage(String message, ...) throws Exception
        </code></pre></div>

        <p>This event handler is called upon receiving a complete text message. The first argument is fixed, but the remaining arguments are dependency-injectable with global object types and <code>WebSocketHandlerContext</code>. You <strong>may not</strong> use <code>lightning.server.Context</code> methods in this handler, but you may use <code>lightning.websockets.WebSocketContext</code> methods.</p>

        <p>If you do not define this event handler on your class, the reciept of a text message will cause the connection to be terminated with status code 1003 (unsupported data type).</p>

        <h3>WEBSOCKET_BINARY_MESSAGE</h3>
        <div class="highlighter-rouge"><pre><code class="java">
@OnEvent(EventType.WEBSOCKET_BINARY_MESSAGE)
public void onBinaryMessage(byte[] data, int offset, int length, ...) throws Exception
        </code></pre></div>

        <p>This event handler is called upon receiving a complete binary message. The first three arguments are fixed, but the remaining arguments are dependency-injectable with global object types and <code>WebSocketHandlerContext</code>. You <strong>may not</strong> use <code>lightning.server.Context</code> methods in this handler, but you may use <code>lightning.websockets.WebSocketContext</code> methods.</p>

        <p>If you do not define this event handler on your class, the reciept of a binary message will cause the connection to be terminated with status code 1003 (unsupported data type).</p>

        <h3>Web Socket Context</h3>

        <p>You may use the static methods on <code>lightning.websockets.WebSocketContext</code> inside of the event handlers for all web socket events except for <code>WEBSOCKET_HANDSHAKE</code>. These APIs will allow you to manage the connection, send messages, and access various aspects of the framework (like the database connection). These are the web socket equivalents of <code>lightning.server.Context</code>.</p>

        <p>Any methods that may safely use <code>WebSocketContext</code> are dependency-injectable with <code>WebSocketHandlerContext</code> (the instance version of the API, much like <code>HandlerContext</code> is to <code>Context</code>).</p>

        <h3>Debug Mode</h3>

        <p>A web socket handler's code may be reloaded automatically in <a href="#debug">debug mode</a> if the class is defined within the <code>autoReloadPrefixes</code> in your <a href="#config">configuration</a>.</p>

        <p>All incoming web socket connections will always use the latest version of the code <em>at the time the connection is established</em>. If at any point a web socket connection involves a handler running outdated code, the framework will terminate that connection the next time that any web socket event occurs on it. If this happens, the triggering event will be dropped, but the <code>WEBSOCKET_CLOSE</code> handler will still be invoked on the old version of the code to allow for clean-up operations to run. When the client reconnects, they will connect to a handler running the latest version of the code.</p>

        <p>The framework guarantees that a remote endpoint <em>will never</em> be allowed to communicate with outdated code. The framework does not, however, terminate existing connections immediately when the code is changed. Instead, the framework waits until the next event on that connection. If no events are occuring on a connection running outdated code, the connection will not be terminated until it times out. To get around this limitation, you may force an immediate reload by refreshing the page in your browser, or you may opt to <a href="#config">configure</a> a lower default time out for web socket connections when running in debug mode.</p>

        <h3>Echo Socket Example</h3>
        <div class="highlighter-rouge"><div class="file">EchoWebSocket.java</div><pre><code class="java">
import static lightning.websockets.WebSocketContext.*;

import lightning.ann.OnEvent;
import lightning.ann.WebSocket;
import lightning.enums.EventType;

@WebSocket(path="/echo")
public class EchoWebSocket {
  @OnEvent(EventType.WEBSOCKET_TEXT_MESSAGE)
  public void handleTextMessage(String message) throws Exception {
    sendText(message);
  }

  @OnEvent(EventType.WEBSOCKET_CONNECT)
  public void handleConnect() throws Exception {
    sendText("Hello!");
  }
}
        </code></pre></div>

        <h3>Tips &amp; Tricks</h3>
        <ul>
          <li>If you need broadcast functionality, you can save sessions to a static <code>ConcurrentHashMap</code> in your <code>WEBSOCKET_CONNECT</code> handler and remove them from the set in your <code>WEBSOCKET_CLOSE</code> handler. You can then iterate through the set to broadcast a message (for example, if you are implementing chat room functionality).</li>
        </ul>
      </section>

      <section>
        <a name="requests"></a>
        <h2>Requests</h2>
        <p>An incoming HTTP request is represented by <code>lightning.http.Request</code>.</p>

        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
import static lightning.server.Context.request;

// List of path segments in the request path
request().segments()

// Access the request path
request().path()

// Return whether or not the request matches a path pattern
// Pattern is in the same format as routing paths
request().matches(pathPattern)

// Returns the complete URL of the request
request().url()

// Returns the request URI
request().uri()

// Returns the content type of the request
request().contentType()

// Returns the HTTP method of the request
request().method()

// Returns the scheme of the request (e.g. HTTP or HTTPS)
request().scheme()

// Returns whether or not the request was encrypted
// Honors load balancer X-Forwarded headers if enabled in config
request().isSecure()

// Returns the host contained in the request
request().host()

// Returns the ip of the remote client
// Honors load balancer X-Forwarded headers if enabled in config
request().ip()

// Properties attached to request:
request().properties()
request().property(name)
request().property(name, value)
request().removeProperty(name)

// Returns names of all route parameters matched
request().routeParams()

// Returns value of parameter with given name
request().routeParam(name)

// Returns the wildcard portion of the path matched
request().wildcardPath()

// Returns the path segments of the wildcard portion of the path matched
request().wildcards()

// Reading unsigned cookies:
// See the doc article on cookies.
request().rawCookies()
request().rawCookie(name)

// Reading query parameters:
request().queryParams()
request().queryParamsExcepting(names)
request().queryParam(name)

// Reading HTTP headers:
request().headers()
request().header(name)

// Processing multipart requests:
// See the doc article on multipart requests.
request().isMultipart()
request().parts()
request().part(name)

// Access raw HttpServletRequest:
request().raw()
        </code></pre></div>
      </section>

      <section>
        <a name="responses"></a>
        <h2>Responses</h2>
        <p>An outgoing HTTP response is represented by <code>lightning.http.Response</code>.</p>
        <p>You should treat responses as being <em>unbuffered</em> (unless you configure output buffering). You may mutate any parts of the response header at will before writing anything to the response body. However, once the first byte is written to the response body, the response is considered <em>committed</em> and further attempts to modify parts of the response header will fail as the response header and any bytes written to the body may already have been transmitted across the network (depending upon server load and configured buffer size).</p>
        <p>By default, responses are sent with a status of <code>200 OK</code> and a content-type of <code>text/html; charset=UTF-8</code>. Unless an explicit content-length is specified before the response is committed, the response will be sent with HTTP chunked transfer encoding.</p>

        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
import static lightning.server.Context.request;

// Whether or not some bytes of the response have
// already been committed (written) to the network
response().hasSentHeaders()

// Set the HTTP status code
response().status(status)

// Set the response to a temporary 302 redirect to a URL.
response().redirect(url)

// Set the response to a redirect to a URL with given status code.
response().redirect(url, status)

// Sets the response content type.
response().type(contentType)

// Returns the content type that should be used for a given file extension.
response().typeForFileExtension(ext)

// Returns the content type that should be used for a given file (local path).
response().typeForFilePath(path)

// Writing output:
response().write(text)
response().writef(format, ...args)
response().writer()
response().outputStream()

// Setting headers:
response().header(name, value)

// Setting raw cookies:
// See doc article on cookies.
response().rawCookie(name, value, path, maxAgeSec, httpOnly, secureOnly)

// Access to raw HTTPServletResponse:
response().raw()
        </code></pre></div>
      </section>

      <section>
        <a name="parameters"></a>
        <h2>Type-Safe Parameters</h2>
        <p>A huge benefit of developing web applications in Java over other languages like PHP or Python is type safety. Unfortunately, ensuring type safety can be difficult when dealing with values whose types cannnot be known at compile time. In particular, web developers will commonly encounter values that are user-provided or deserialized from external storage systems. To enable type safety in these situations, Lightning provides the <code>Param</code> and <code>ObjectParam</code> value wrapper classes.</p>
        <p>You may have noticed that, throughout the Lightning APIs, most methods that return a user-provided string value (such as <code>request().queryParam(name)</code>) return an instance of <code>lightning.mvc.Param</code> instead of a nullable <code>String</code> or <code>Optional&lt;String&gt;</code>. Similarly, most methods that return an object value of unknown type (such as <code>session().get(key)</code>) return an instance of <code>lightning.mvc.ObjectParam</code> instead of a nullable <code>Object</code> or <code>Optional&lt;Object&gt;</code>.</p>

        <p>Let's consider a query parameter (form field) for which you want to accept an integer. In Lightning, you can conveniently write:</p>
        <div class="highlighter-rouge"><div class="file">Code Snippet</div><pre><code class="java">
import static lightning.server.Context.*;
int age = queryParam("age").intValue();
        </code></pre></div>
        <p>If the user-provided value does not exist or is not an integer, then invoking <code>intValue()</code> throws a <code>BadRequestException</code> preventing further execution of the handler and invoking the <a href="#exceptions">exception handler</a> for <code>BadRequestException</code> (by default, the handler renders an HTTP 400 error page).</p>
        <p><strong>Key Idea: </strong> Using <code>intValue()</code> to catch user input errors <em>is not</em> the most user-friendly way of type checking user-provided values. Typically, you would want to use a <a href="#validation">validator</a> to re-render the form with error messages. However, <code>intValue()</code> does ensure that the given value is <em>always</em> an integer thus preventing you from accidently storing incorrect data types to a database in any situation. This is particularly important if you are using a database that is not well structured (e.g. a no-SQL JSON document store such as RethinkDB or MongoDB).</p>
        <p><code>Param</code> provides many other convenience methods for dealing with array input, checkboxes, enums, doubles, and more. See <a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/mvc/Param.java" target="_blank">Param.java</a> for the complete API.</p>
        <p><code>ObjectParam</code> provides convenience methods for a casting an instance of <code>Object</code> to a more specific type such as <code>List&lt;String&gt;</code>. If the conversion cannot be formed, a <code>TypeConversionException</code> is thrown which will invoke the corresponding exception handler (by default, this renders a 500 Internal Server Error page). This is convenient for retrieving serialized values stored in the <a href="#caches">cache</a> or <a href="#sessions">session</a>. See <a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/mvc/ObjectParam.java" target="_blank">ObjectParam.java</a> for the complete API.</p>
        <p>For example, to retrieve a list of strings stored on a user's session or create a new empty list if that key does not exist or if the value for that key is not of the expected type:</p>

        <div class="highlighter-rouge"><div class="file">Code Snippet</div><pre><code class="java">
List&lt;String&gt; data = session().get("key").listOption(String.class).or(new ArrayList&lt;String&gt;());
        </code></pre></div>

      </section>

      <section>
        <a name="templates"></a>
        <h2>Templates</h2>
        <p>In Lightning, a template is rendered from a view name and a view model. Templates produce some sort of text output (typically HTML). The format of the view model is dependent upon the template engine you configure.</p>
        <p>By default, Lightning utilizes the FreeMarker Template Engine to render views. With FreeMarker, view names are simply the name of the template file (relative to the template files path specified in your config) and view models are simply a map of variable names to their respective values. For template language syntax and features, refer to the <a href="http://freemarker.org/" target="_blank">FreeMarker Documentation</a>.</p>
        <p>You must configure a template files directory to use templates. You may configure a different template engine if you do not like FreeMarker. For information on configuring templates, see <a href="#config">Configuration</a>.</p>
        <p><strong>SECURITY ADVISORY:</strong> The template engine you are using may not automatically escape HTML characters (including the default FreeMarker template engine). You should take precautions to protect your application against XSS attacks. FreeMarker provides <a href="http://freemarker.org/docs/dgui_misc_autoescaping.html" target="_blank">auto-escaping</a> functionality for this purpose.</p>

        <p>Templates may be rendered a variety of different ways:</p>
        
        <h3>Option 1</h3>
        <p>You may return the view model from a route handler annotated with <code>@Template(name)</code>. This method is preferred when you know the name of the template at compile-time.</p>
        <div class="highlighter-rouge"><div class="file">MyTemplateController.java</div><pre><code class="java">
@Controller
public final class MyTemplateController {
  @Route(path="/", methods={GET})
  @Template("view.ftl")
  public Map&lt;String, ?&gt; handleView() throws Exception {
    return ImmutableMap.of("key1", "value1", "key2", "value2");
  }
}
        </code></pre></div>

        <h3>Option 2</h3>

        <p>You may return an instance of <code>ModelAndView</code> from a route handler annotated with <code>@Template</code>. This method is preferred when you do not know the name of the template at compile-time.</p>
        <div class="highlighter-rouge"><div class="file">MyTemplateController.java</div><pre><code class="java">
@Controller
public final class MyTemplateController {
  @Route(path="/", methods={GET})
  @Template
  public ModelAndView handleView() throws Exception {
    return modelAndView("view.ftl", 
                        ImmutableMap.of("key1", "value1", 
                                        "key2", "value2"));
  }
}
        </code></pre></div>

        <h3>Option 3</h3>

        <p>You may use the template APIs (on <code>lightning.server.Context</code>):</p>
        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
// To create a ModelAndView:
modelAndView(viewName, viewModel)

// To render a model and view to a String:
renderToString(modelAndView)
renderToString(viewName, viewModel)

// To render a model and view to the response body:
render(modelAndView)
render(viewName, viewModel)
        </code></pre></div>
      </section>

      <section>
        <a name="json"></a>
        <h2>JSON</h2>

        <p>Lightning includes built-in support for parsing and generating JSON. By default, Lightning uses <a href="https://github.com/google/gson" target="_blank">gson</a>. You may <a href="#config">configure</a> Lightning to use a different JSON library if you prefer.</p>

        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
import static lightning.server.Context.*;

// Parse JSON from the value of a query parameter.
parseJsonFromParam(queryParamName, clazz)
parseJsonFromParam(queryParamName, clazz, policy)

// Parse JSON from the request body.
parseJson(clazz)
parseJson(clazz, policy)

// Parse JSON from a String.
parseJson(json, clazz)
parseJson(json, clazz, policy)

// Convert a Java object to a JSON string.
toJson(object)
toJson(object, policy)

// Set headers and write a Java object to response as JSON.
sendJson(object)
sendJson(object, prefix)
sendJson(object, policy)
sendJson(object, prefix, policy)
        </code></pre></div>

        <p>You may indicate that a route handler returns an object that should be JSONified using the <code>@Json</code> annotation. The framework will automatically convert the object to JSON and set headers accordingly as if you had invoked <code>sendJson</code>.</p>

        <div class="highlighter-rouge"><div class="file">ExampleJsonController.class</div><pre><code class="java">
@Controller
public final class ExampleJsonController {
  @Route(path="/", methods={GET})
  @Json
  public Object handleRequest() throws Exception {
    return ImmutableMap.of("key1", "value1", "key2", "value2");
  }
}
        </code></pre></div>

        <p>The Lightning JSON APIs optionally allow you to specify an XSSI prefix (to mitigate XSSI attacks) and a field name conversion policy between Java objects and JSON.</p>

                <div class="highlighter-rouge"><div class="file">ExampleJsonInputController.class</div><pre><code class="java">
@Controller
public final class ExampleJsonInputController {
  public static class MyType {}

  @Route(path="/", methods={POST})
  // Specifies to parse JSON contained in request body to MyType
  // and dependency-inject the data into the method. If request 
  // body is not present/not valid json/not of type MyType, 
  // a BadRequestException is thrown.
  @JsonInput(type=MyType.class) 
  public void handleRequest(MyType data) throws Exception {
    doThingsWithData(data);
  }
}
        </code></pre></div>


      </section>

      <section>
        <a name="validation"></a>
        <h2>Form Validation</h2>
        <p>Each request has an attached <code><a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/mvc/Validator.java" target="_blank">Validator</a></code> that can be used to perform form (query parameter) validation on that request. The general usage of validators follows:</p>
        <div class="highlighter-rouge"><div class="file">General Usage</div><pre><code class="java">
import static lightning.server.Context.*;

// Specify what you want to validate:
validate("agreement").isChecked();
validate("email").isEmail().isNotEmpty();
validate("year").isNumberBetween(2000, 2100);
validate("file").isFileSmallerThan(1024);
validate("answer").isOneOf("A","B","C","D");

// Check if the constraints you specified hold true for the request:
if (passesValidation()) {
  // If validation succeeds, make changes to the database.
  saveData(request);
  showSuccessPage();
} else {
  // Otherwise, show errors to user (map of query param names to associated error(s)).
  Map&lt;String, String&gt; errors = validator.getErrors();
  showErrorPage(errors);
}
        </code></pre></div>
        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
validator()
validator().addError(field, errorMessage)
validator().getErrors()
validator().getErrorOption(field)
validator().getErrorsAsString()
validator().passes() // (aliases passesValidation(), !validator().hasErrors())
validateXsrf(field)
validateXsrf()
validate(field).addError(errorMessage)
validate(field).isEmail()
validate(field).isURL()
validate(field).isPresent()
validate(field).isNotChecked()
validate(field).isChecked()
validate(field).is(requiredValue, errorMessageIfFailed)
validate(field).isShorterThan(chars)
validate(field).isLongerThan(chars)
validate(field).isNotEmpty(chars)
validate(field).isAlpha()
validate(field).isAlphaNumeric()
validate(field).isAlphaNumericWithSpaces()
validate(field).isAlphaWithSpaces()
validate(field).isAlphaNumericDashUnderscore()
validate(field).isLong()
validate(field).isDouble()
validate(field).isPositiveNumber()
validate(field).isPositiveNonZeroNumber()
validate(field).isNumberAtLeast(n)
validate(field).isNumberAtMost(n)
validate(field).isNumberInRange(min, max)
validate(field).isOneOf(list)
validate(field).containsOnly(list)
validate(field).hasNoDuplicates()
validate(field).isNonEmptyFile()
validate(field).isFile()
validate(field).isFileSmallerThan(bytes)
validate(field).isFileOfType(typeList)
validate(field).isFileWithExtension(extList)
validate(field).isEnum(enumType)
validate(field).matches(regex, errorMessageIfFailed)
validate(field).matches(pattern, errorMessageIfFailed)
validate(field).matches(() -> { return true|false; }, errorMessageIfFailed)
        </code></pre></div>
      </section>

      <section>
        <a name="urls"></a>
        <h2>URL Generation</h2>
        <div class="notice"><strong>Work-In-Progress:</strong> This API is not yet completed but existing APIs will not change in future releases.</div>
        <p>Provides assistance with generating absolute URLs to application paths.</p>
        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
import static lightning.server.Context.url;

// Generates the complete (full) URL to a given path (including schema, host, etc).
url().to(path)

// Generates the complete (full) URL to a given path (including schema, host, etc)
// with the given query parameters.
url().to(path, queryParams)
        </code></pre></div>
      </section>

      <section>
        <a name="cookies"></a>
        <h2>Cookies</h2>
        <p>Cookies can be used to store transient client (browser) specific data. Cookies can be thought of as a map of variable names to string values. Cookies are stored with the client and are therefore subject to direct viewing, tampering, and sudden deletion.</p>
        <p>To ensure the integrity of cookies, Lightning will automatically sign the cookies you set with HMAC SHA256 and verify the signatures before allowing you to read the value of the cookie. This signing and verification process is made completely transparent to you by the Cookies API. This signing process prevents users from forging and modifying cookies, but does not prevent one user from copying another's cookies, sudden deletion of cookies, or disclosure of cookie values. If a cookie's signature cannot be verified, the API will act as if the user did not send that cookie. If you prefer to use raw (unsigned) cookies, you may use the <a href="#requests">Request</a> and <a href="#responses">Response</a> rawCookie APIs instead.</p>
        <p>Attempting to set a cookie after the response headers have already been committed will throw an exception. You should set all cookies before taking an action that would commit the response or enable output buffering in your configuration.</p>
        <p>Cookies are sent with <code>HTTP ONLY</code> unless specified otherwise in an API invocation. This flag prevents the value of the cookie from being tampered with or read by JavaScript code and reduces the surface for XSS attacks.</p>
        <p>Cookies are sent with <code>SECURE ONLY</code> if SSL is enabled in <a href="#config">config</a> unless specified otherwise in an API invocation. This flag prevents the contents of the cookie from being accidently disclosed over an insecure connection.</p>
        <p>To utilize the cookies API, you must <a href="#config">configure</a> an HMAC private key.</p>
        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
import static lightning.server.Context.cookies;

cookies().set(name, value)
cookies().set(name, value, path, maxAgeSec, httpOnly)
cookies().set(name, value, path, maxAgeSec)
cookies().set(name, value, maxAgeSec)
cookies().has(name)
cookies().get(name)
cookies().delete(name)
cookies().all()
cookies().asMap()
        </code></pre></div>
      </section>

      <section>
        <a name="sessions"></a>
        <h2>Sessions</h2>

        <p>Sessions can be used to store transient client (browser) specific data in a server-side data storage system. Conceptually, sessions can be thought of as a map of variable names to values. You may store any type of <code>java.io.Serializable</code> object as a value in the session store. Sessions <em>can not</em> be used to store persistent data as either the storage sytem or user may elect to terminate the session at any point in time.</p>

        <p>Sessions serve a purpose similar to cookies but, unlike cookies, users cannot directly view or alter the information stored in their session and the size of each value is not limited. You should prefer using cookies where safe and possible since they are impose no server-side overhead.</p>

        <p>The storage system used to back sessions is <a href="#config">configurable</a>. Sessions are linked between the storage system and the user's browser by an HMAC-signed cookie containing a random session identifier. The data storage system remembers only a hash of the session identifier. The framework does not provide protection against session fixation attacks; you should invoke <code>regenerateId()</code> in your application logic when neccessary to mitigate these types of attacks (note the <code>Auth</code> login API will automatically do this).</p>

        <p>Sessions are <em>lazy-loaded</em> - no calls to underlying storage will be made unless a controller invokes a method on <code>session()</code>. Sessions are automatically saved if they have been modified when you return from a route handler. Session saves may fail if the response has already been committed prior to returning from a route handler since the session cookie cannot be set - to get around this, manually invoke <code>save()</code> before taking an action that could commit the response or enable output buffering in your configuration.
        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
import static lightning.server.Context.session;

// Getting and setting values:
session().keys()
session().set(key, value)
session().get(key)
session().forget(key)
session().has(key)
session().asMap()

// Getting the XSRF token:
session().xsrfToken()

// Change the XSRF token and get the new one:
session().newXsrfToken()

// Change the session identifier:
session().regenerateId()

// Dirty sessions are automatically saved when you return from handler.
// To force immediate save of session, you may invoke this.
session().save()
        </code></pre></div>
      </section>

      <section>
        <a name="users"></a>
        <h2>Users, Groups, &amp; Permissions <!-- WIP --></h2>
        <p>Users, Groups, Permissions, and <a href="#auth">Auth</a> are all backed by storage drivers that must be <a href="#config">configured.</a>
        <p><strong>Users</strong> are Lightning's internal representation of user management.</p>
        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
import static lightning.server.Context.*;

// --- Methods for interacting with users in aggregate ---

// Returns the user with given id (if exists).
users().getById(id)

// Returns the user with given username (if exists).
users().getByName(username)

// Returns the user with given email (if exists).
users().getByEmail(email)

// Returns an iterator over all user accounts.
// This iterator efficiently fetches from the underlying storage system in chunks.
users().getAll()

// Creates and returns a new user with given username, email, and password.
users().create(username, email, password)

// Deletes a user.
// Only deletes data stored by Lightning.
users().delete(user)

// --- Methods for interating with an individual user ---

User user = /* .. obtain using one of above methods .. */;
user.emailIsVerified()
user.setEmailIsVerified(isVerified)
user.getToken()
user.setToken(token)
user.getId()
user.getUserName()
user.getEmail()
user.setEmail(email)
user.isBanned()
user.getBanExpiry()
user.banUntil(timestamp)
user.setPassword(password)
user.checkPassword(password)

// Users can be used as a key-value store.
// String keys and any type of java.io.Serializable value are supported.
user.getProperties()
user.hasProperty(key)
user.setProperty(key, value)
user.deleteProperty(key)
user.getProperty(key)
user.getPropertyCount()

// These methods all take into account the set union of the permission set
// of the individual user and all groups the user is a member of.
user.hasPrivilege(pid)
user.hasPrivilegeOnUser(pid)
user.grantPrivilege(pid)
user.revokePrivilege(pid)
user.getPrivilegeSet()
user.getPrivileges()
user.getPrivilegesOnUser()
user.hasPrivileges(pids)
user.hasPrivilegesOnUser(pids)
user.grantPrivileges(pids)
user.revokePrivileges(pids)

// Users may be a member of one or more permission groups.
user.getGroups()

// User changes are not pushed to the underlying data store until save() is invoked.
// save() may fail if changes violate constraints (e.g. usernames must be unique).
user.save()
        </code></pre></div>
        <p><strong>Groups</strong> simply aggregate together a set of users. Users may be members of more than one group. Permissions may be set on groups, and members of the group will inherit any permissions granted to the group.</p>
        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
// --- Methods for interacting with groups in aggregate --
groups().get(id)
groups().getByName(name)
groups().getAll()
groups().create(name)
groups().delete(group)

// --- Methods for interacting with an individual group --
Group group = /* ... obtain using one of above methods ... */;
group.getId()
group.getName()
group.setName(name)
group.getPrivileges()
group.hasPrivilege(pid)
group.grantPrivilege(pid)
group.revokePrivilege(pid)
group.hasPrivileges(pids)
group.grantPrivileges(pids)
group.revokePrivileges(pids)
group.addUser(user)
group.removeUser(user)
group.hasUser(user)
group.getUserIds()
group.hasUsers(users)
group.addUsers(users)
group.removeUsers(users)
        </code></pre></div>
        <p><strong>Permissions</strong> (or Privileges) are simply integers. The meaning of these integers is undefined by the framework - it is up to you to decide what each possible value represents and enforce them. Our recommendation is to define an enum of all Permissions and use the ordinals.</p>
        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
// Define your own class:
public enum Permissions {
  CREATE_USER,
  MANAGE_USERS,
  POST_ANNOUNCEMENTS,
  /* ... etc ... */;
}

// Then you can use the ordinal for a privilege id. For example:
if (user().hasPrivilege(Permissions.MANAGE_USERS.ordinal())) {
  // ... allow access ...
}
        </code></pre></div>
      </section>

      <section>
        <a name="auth"></a>
        <h2>Authentication <!-- WIP --></h2>
        <p>You must <a href="#config">configure</a> a storage driver for users, groups, and auth to use these APIs. The authentication APIs provide a way for securely handling user authentication and are configured to be resilient against all known forms of attack by default <em>if you deploy using SSL</em>. The authentication API uses a cookie to link the client (browser) to an authentication session in your persistent data store.</p>
        <p>Authentication sessions are typically short-lived (inactivity timeout of one hour unless configured differently). Authentication sessions are long-lived (inactivity timeout of two weeks unless configured differently) only if the persistent flag is set.</p>
        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
import static lightning.server.Context.*;

// Returns whether or not a user is authenticated.
isLoggedIn() // (alias auth().isLoggedIn())

// Returns currently authenticated user.
// Throws NotAuthorizedException if not authenticated.
user() // (alias auth().user())

// Logs out currently authenticated user (if any).
// Terminates all persistent auth tokens on the client if requested.
// NOTE: The user will not truly be logged out unless removePersistentTokens=true.
auth().logout(removePersistentTokens)

// Logs client in as given user (optionally persistent).
// Will indicate user has entered their password recently unless isFromToken.
auth().loginAs(user, isPersistent, isFromToken)

// Attempts to authenticate using given username and password.
// Optionally makes the authentication session persistent.
// Optionally accepts extra info (passed to the underlying auth driver) - usually null.
// This method will check security measures (such as throttling).
// Will indicate the user has entered their password recently if successful.
// Throws an AuthException if unsuccessful.
auth().attempt(username, plaintextPassword, isPersistent, extraInfo)

// Use to manage other sessions logged in to a user's account.
auth().terminateAllSessionsForUser(user)
auth().terminateOtherSessions()

// Use to check the password of the currently logged-in user.
// Throws exception if not authenticated.
// Will indicate user has entered their password recently if successful.
// Subject to security measures such as throttling.
auth().checkPassword(plaintextPasword)

// Use to check that the user has confirmed their identity recently by entering their
// actual password.
// Useful to restrict access to sensitive data (e.g. billing info).
// This can be used to prevent someone who walks up to a machine with an already logged in user
// from making changes to that user's account without knowing their password. You can configure
// a timeout period.
auth().hasEnteredPasswordRecently()
        </code></pre></div>
        <p>Route handlers may be annotated with <code>@RequireAuth</code> to filter unauthenticated requests.</p>


        <p>By default, we utilize a SQL database driver to store users, sessions, and authentication. You may <a href="#config">configure</a> different storage drivers if you wish. To use the provided database storage driver, you simply need to import the <a href="https://github.com/lightning-framework/lightning/tree/master/src/main/resources/lightning/schema" target="_blank">schema</a> into your database.</p>
        <p>Our APIs provide convenience methods for handling authentication, sessions, and user data. However, you'll still need to make your own log in, log out, and registration controllers. We have included some skeletons for your convenience.</p>

        <div class="highlighter-rouge"><div class="file">/src/main/java/myapp/controllers/AuthController.java</div><pre><code class="java">
public final class AuthController {
  @Route(path="/login", methods={GET})
  @Template('login.ftl')
  public Object handleLoginGET() throws Exception {
    // Display your login form.
    return ImmutableMap.of(); // The view model.
  }

  @Route(path="/register", methods={GET})
  @Template('register.ftl')
  public Object handleRegisterGET() throws Exception {
    // Display your registration form.
    return ImmutableMap.of(); // The view model.
  }

  @Route(path="/logout", methods={GET})
  public void handleLogoutGET() throws Exception {
    if (isLoggedIn()) {
      auth().logout(true);
    }

    redirect(url.to("/"));
  }

  @Route(path="/login", methods={POST})
  @Template('login.ftl')
  public Object handleLoginPOST() throws Exception {
    redirectIfLoggedIn(url.to("/"));

    // Add form validation.
    validate("username").isNotEmpty();
    validaet("password").isNotEmpty();

    try {
      if (passesValidation()) {
        // Delegate to framework authentication.
        String username = queryParam("username").stringValue();
        String password = queryParam("password").stringValue();
        boolean persistent = queryParam("persistent").isChecked();
        auth().attempt(username, password, persistent, null);
        redirect(url().to("/profile"));
      }
    } catch (AuthException e) {
      switch (e.getType()) {
        case NO_USER:
        case INVALID_PASSWORD:
        case INVALID_USERNAME:
        case USER_BANNED:
          validator().addError("username", "Invalid username/password combination.");
          break;
        case IP_THROTTLED:
        case USER_THROTTLED:
          validator().addError("username", "You must wait before trying again.");
          break;
        default:
          throw e; // Re-throw the exception to generate an internal server error.
      }
    }

    // Re-show login page with errors if authentication failed.
    return ImmutableMap.of("errors", validator.getErrors()); // View model for template.
  }

  @Route(path="/register", methods={POST})
  public void handleRegisterPOST() throws Exception {
    // TODO: Add form validation.
    validate("username").isShorterThan(30)
                        .isLongerThan(3)
                        .isAlphaNumeric();
    validate("password").isLongerThan(5)
                        .isShorterThan(100);
    validate("email").isEmail();

     if (passesValidation()) {
      // Create the user account.
      String username = queryParam("username").stringValue();
      String password = queryParam("password").stringValue();
      String email = queryParam("email").stringValue();

      // Note: exception will be thrown on failure (e.g. duplicate username).
      User user = users().create(username, email, password);
      render('register_success.ftl', ImmutableMap.of());
      return;
    }

    // Re-show registration form on error.
    render('register.ftl',
           ImmutableMap.of("errors", validator.getErrors()); // View model for template.
  }
}
        </code></pre></div>
        <p>You can access the currently authenticated user in any of your controllers by invoking <code>user()</code>. If no user is logged in, a <code>NotAuthorizedException</code> is thrown which generates an HTTP 401 error page. You can check if a user is logged in by invoking <code>isLoggedIn()</code>. Annotating a route with <code>@RequireAuth</code> will filter unauthenticated requests for that route. Alternatively, you may want to look into using path-based filters.</p>

      </section>

      <section>
        <a name="email"></a>
        <h2>Email</h2>
        <p>To utilize the email API, you must <a href="#config">configure</a> SMTP or the logging driver.</p>
        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
import static lightning.server.Context.mail;

Message message = mail().createMessage();
message.addRecipient(email)
message.addRecipient(email, name)
message.addCC(email)
message.addCC(email, name)
message.addBCC(email)
message.addBCC(email, name)
message.setSubject(subject)
message.setText(text)
message.setText(stream)
message.setHTMLText(text)
message.setHTMLText(stream)
message.addAttachment(fileName, mimeType, inputStream)
message.addAttachment(path)
message.addAttachment(file)
message.addAttachment(fileName, dataSource)

// Sends a message (blocking).
mail().send(message);

// Sends a message asynchronously (fire and forget).
mail().sendAsync(message);
        </code></pre></div>
        <p>The Mail API does not support retries, queueing, or guarantee delivery. If you need these features, you should utilize your own mailing library. See <a href="#external">Using External Tools</a>.</p>
      </section>

      <section>
        <a name="caches"></a>
        <h2>Cache</h2>
        <p>The cache is a globally-shared transient key-value store meant to be backed by a technology like Memcached or Redis.</p>
        <p>The cache API supports <code>String</code> keys and any type of <code>java.io.Serializable</code> object may be stored as a value.</p>
        <p>To utilize the cache API, you must <a href="#config">configure</a> a cache driver.</p>
        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
import static lightning.server.Context.cache;

cache().get(key, type, () -> { return default; })
cache().get(key, type, () -> { return default; }, expiration)
cache().get(key)
cache().gets(key)
cache().set(key, value)
cache().set(key, value, exiration)
cache().delete(key)
cache().increment(key, amount, initial, expiration)
cache().increment(key, amount, initial)
cache().decrement(key, amount, initial, expiration)
cache().decrement(key, amount, initial)
cache().cas(key, token, value, expiration)
cache().cas(key, token, value)
cache().touch(key, expiration)
cache().touch(key)
cache().clear()
        </code></pre></div>
      </section>

      <section>
        <a name="async"></a>
        <h2>Async Handlers &amp; SSE</h2>
        <h3>Async Handlers</h3>
        <p>An asynchronous handler alters a request's life cycle enabling it to outlive the invocation of a request handler. You may use this functionality to release the thread reserved for processing the request back into the server thread pool while waiting for a lengthy I/O operation. An example follows:</p>
        <div class="highlighter-rouge"><div class="file">AsyncController.java</div><pre><code class="java">
import lightning.ann.*;
import lightning.mvc.HandlerContext;

import static lightning.enums.HTTPMethod.*;
import static lightning.server.Context.*;

import java.util.concurrent.TimeUnit;

@Controller
public class AsyncController {
  @Route(path="/asyncDemo", methods={GET})
  public void handleRequestAsync() throws Exception {
    // Invoke goAsync to start asynchronous mode.
    // An async context is returned to facilitate this.
    // HandlerContext is the instance version of lightning.server.Context.
    // lightning.server.Context methods ARE NOT SAFE TO USE after going async.
    HandlerContext context = goAsync();

    // You may offload the request processing to another thread or queue it up
    // for some lengthy I/O operation.
    ((new Thread() {
      @Override
      public void run() {
        try {
          for (int i = 0; i &lt; 5; i++) {
            Thread.sleep(TimeUnit.SECONDS.toMillis(1));
            // When you decide you are ready to work on the response, you can
            // use the async context to do so:
            context.response().write("Hello World!\n");
            context.response().flush();
          }
        } catch (Throwable e) {
          // This is the recommended way to handle top-level exceptions as it will
          // log the error and then follow the standard exception handling path.
          context.handleException(e);
        } finally {
          // IMPORTANT: You must close to context when you are finished servicing
          //            the request to avoid leaking resources.
          context.close();
        }
      }
    })).start();

    // Returning releases the thread back into the server thread pool to handle another request.
  }
}
        </code></pre></div>

        <h3>Server-Sent Events (SSE)</h3>
        <div class="notice">A native API for SSE (Server-Sent Events) is not available.</div>
        <p>It is possible to utilize asynchronous handlers to efficiently emit events to a server-sent event stream. We leave it as an exercise to the reader to implement the infrastructure for handling an SSE endpoint efficiently since it would likely be application-specific. You may find the <a href="https://www.w3.org/TR/eventsource/" target="_blank">SSE Specification</a> and Jetty's <a href="https://github.com/jetty-project/jetty-eventsource-servlet/blob/master/src/main/java/org/eclipse/jetty/servlets/EventSourceServlet.java" target="_blank">EventSourceServlet implementation</a> useful.</p>
      </section>

      <section>
        <a name="multipart"></a>
        <h2>Multipart &amp; File Uploads</h2>
        <p>To handle multipart requests, you must <a href="#config">configure</a> multipart support and indicate which routes accept multipart requests by annotating them with <code>@Multipart</code>. Multipart requests sent to handlers that are not annotated with <code>@Multipart</code> will be dropped. <code>Request::queryParam</code> and <a href="#validation">form validators</a> work properly for forms submitted with multipart encoding.</p>
        <p>An example of handling a file upload follows:</p>
        <div class="highlighter-rouge"><div class="file">FileUploadController.java</div><pre><code class="java">
@Controller
class FileUploadController {
  @Route(path="/upload", methods={POST})
  @Multipart
  public void handleUpload() throws Exception {
    String fileName = request().part("file").getSubmittedFileName();
    long fileSize = request().part("file").getSize();
    InputStream fileContent = request().part("file").getInputStream();
    // ... Validate the file, store its contents, and build the response ...
  }
}
        </code></pre></div>
      </section>

      <section>
        <a name="sql"></a>
        <h2>SQL Database Access</h2>
        <p>Lightning ships convenience functions for accessing a MySQL database through a connection pool. The usage of this functionality is entirely optional. In order to use these APIs, you'll need to <a href="#config">configure</a> a database connection under the <code>db</code> property.</p>

        <div class="info-box">
        A <em>connection-pool</em> (<code>MySQLDatabaseProvider</code>) is a thread-safe factory used by worker threads to obtain non-thread-safe database connection objects (<code>MySQLDatabase</code>) for temporary, exclusive use. Connection pools typically maintain a variable-sized pool of connections that workers may lease. If the pool is exhausted, then attempting to lease a connection from the pool will block until one is available. When a worker is finished with a leased connection, it must <code>close()</code> the connection to return it to the pool for re-use. Connection pools are convenient since re-using connections avoids the round trip times needed to set up a new connection. For more information, see <a href="https://en.wikipedia.org/wiki/Connection_pool" target="_blank">Connection Pooling - Wikipedia</a>.
        </div>

        <p>To obtain a thread-unsafe database connection from the connection pool, you may invoke <code>db()</code> (on <code>lightning.server.Context</code>) from within a route handler, filter, or exception handler. The connection you obtain will be reserved for exclusive use by the calling thread from the point at which you first invoke <code>db()</code> until the request is completely handled. Thus, route handlers that do not utilize the database will not consume any resources from the pool and subsequent invocations of <code>db()</code> for the same request will return the same connection. Since the database connection is automatically returned to the pool by the framework, you do not need to <code>close()</code> the connection returned by <code>db()</code> (though it <em>is not</em> harmful to do so). You must still, however, explicitly close any prepared statements or result sets that you create using that connection (Java's try-with-resources blocks are convenient for this).</p>

        <div class="info-box">
        To use the database with web sockets, you can <a href="#deps_injection">dependency inject</a> the connection pool into your <code>@WebSocket</code>. See <a href="#web_sockets">Web Sockets</a> for more information.<br />
        <br />
        To use the database with <a href="#async">async handlers</a>, you should not invoke <code>db()</code> - this will reserve the connection until the async context is closed. Instead, you should use the connection pool directly to lease a connection when needed. A reference to the pool can be obtained via dependency injection on <code>MySQLDatabaseProvider</code>.<br />
        <br />
        If you use the pool directly, keep in mind that a single thread must never be able to hold a lease on more than one connection simultaneously - doing so creates the potential for a deadlock.
        </div>

        <p>Lightning's database connections provide access to the standard <code>java.sql</code> APIs. In addition, Lightning includes some quality of life improvement macros and classes. You should prefer using Lightning's <code>NamedPreparedStatement</code> to the standard <code>java.sql.PreparedStatement</code>.</p>

        <p>To issue a database query and process the result:</p>

        <div class="highlighter-rouge"><div class="file">Code Snippet</div><pre><code class="java">
// Note the usage of Java's try-with-resources to ensure proper freeing of resources.
// NamedPreparedStatement functions similarly to java.sql.PreparedStatement.
// Placeholders are named and prefixed with a ":".
// Create the prepared statement.
try (NamedPreparedStatement query = db().prepare(
             "SELECT * FROM users WHERE age >= :age;")) {
  // Fill in the placeholders in the statement.
  query.setInt("age", 21);

  // Executing the statement returns the standard java.sql.ResultSet.
  try (ResultSet result = query.executeQuery()) {
    // Advance the cursor while a next row exists.
    while (result.next()) {
      // For each row, use result.getXXX methods to read columns.
      String username = result.getString("username");
      doSomethingWith(username);
    }
  }
}
        </code></pre></div>

<p>The complete database API:</p>

        <div class="highlighter-rouge"><div class="file">API Reference</div><pre><code class="java">
// Initiates a database transaction on the queries contained in a closure.
// The closure may return nothing OR a value.
// If the given closure returns a value, transaction() will also return that value.
// If not specified, isolation level defaults to connection isolation level.
T value = db().transaction(() -> {
                               /* ... queries ... */
                               return (T)value;
                           })
T value = db().transaction(() -> {
                              /* ... queries ... */
                              return (T)value;
                           },
                           isolationLevel)
db().transaction(() -> { /* ... queries ... */ })
db().transaction(() -> { /* ... queries ... */ }, isolationLevel)

// Return underlying java.sql.Connection.
db().raw()

// Prepare a NamedPreparedStatement (optionally filling in some values).
// Example Format: SELECT * FROM mytable WHERE name = :name;
// Use an SQLNull of the appropriate type as a value in the map to set a NULL.
db().prepare(query)
db().prepare(query, colNameToValMap)

// Prepare an INSERT or REPLACE statement into a given table using the given
// map of column names to column values.
db().prepareInsert(table, colNameToValMap)
db().prepareReplace(table, colNameToValMap)

// Paginate an SQL query (in NamedPreparedStatement format).
// Given query must not already contain a LIMIT clause.
// Map specifies the parameters for the NamedPreparedStatement.
DatabasePaginator results = db().paginate(query, colNameToValMap, pageSize)
results.getTotalPages()
results.getTotalRows()
results.getPageSize()
results.getSizeOfPage(k)
results.hasPage(k)
results.forEachRowInPage(k, (ResultSet row) -> { ... })
results.forPage(k, (ResultSet row) -> { ... })
results.getQueryForPage(k)
        </code></pre></div>
        <p>Lightning provides <a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/db/SQLNull.java"><code>SQLNull</code></a> and <a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/db/ResultSets.java"><code>ResultSets</code></a> to help deal with the poor support for reading and setting NULL values in the built in <code>java.sql</code> APIs. Further, <a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/db/NamedPreparedStatement.java"><code>NamedPreparedStatement</code></a> provides some convenience methods for common operations (execute an update and close, fetch inserted keys, etc).</p>
        <p>An example of utilizing transactions:</p>
        <div class="highlighter-rouge"><div class="file">Code Snippet</div><pre><code class="java">
long customerId = db().transaction(() -> {
  long insertedId = db().prepareInsert(
    "customers",
    ImmutableMap.of(
      "name": "Bob",
      "email": "bob@example.com"
    )
  ).executeInsertAndClose();

  db().prepareInsert(
    "logs",
    ImmutableMap.of(
      "type": "CREATE_USER",
      "customer_id": insertedId
    )
  ).executeUpdateAndClose();

  return insertedId;
});
        </code></pre></div>
      </section>

      <section>
        <a name="external"></a>
        <h2>External DBs and Tools</h2>
        <p>To utilize an external tool, the simplest way is to <a href="#deps_injection">dependency inject</a> an instance of the tool.</p>
        <p>For the remainder of this article, we will provide an example of how one might utilize Lightning with the popular open source database <a href="http://rethinkdb.com/" target="_blank">RethinkDB</a>. You could generalize this to support any external tool or database system.

        <p>To get started, you must first add the RethinkDB Java connector as a Maven dependency by altering your <code>pom.xml</code>. Then, to integrate RethinkDB with Lightning, we will build an instance of a connection pool and then dependency inject that connection pool.</p>

        <div class="info-box">
        A <em>connection pool</em> is a thead-safe factory that maintains a pool of active database connections. Worker threads may lease a non-thread-safe database connection for temporary, exclusive use (e.g. to service an incoming request) and release the connection back into the pool once finished with it.
        </div>


        <div class="highlighter-rouge"><div class="file">AppLauncher.java</div><pre><code class="java">
public final class AppLauncher {
  public static void main(String[] args) throws Exception {
    Config config = makeConfig();
    InjectorModule injector = new InjectorModule();
    // Build a connection pool and dependency inject it.
    // NOTE: RethinkDBCP is not provided by the official driver, you'll need to write
    // your own connection pool or pick an open source one. Conceptually, for the
    // purpose of this tutorial, there's no difference.
    injector.bindClassToInstance(RethinkDBCP.class, makeRethinkDBCP());
    (new LightningServer(config, injector)).start().join();
  }

  public RethinkDBCP makeRethinkDBCP() throws Exception {
    // Build and return a connection pool for the desired database.
    // You need to implement this.
    throw new NotImplementedException();
  }

  public Config makeConfig() throws Exception {
    // Build and return your desired config.
    // You need to implement this.
    throw new NotImplementedException();
  }
}
        </code></pre></div>

        <p>To make using the pool more convenient, you can create an <code>AbstractController</code> from which all other controllers will inherit. <code>AbstractController</code> will provide a convenience method <code>r()</code> which returns a database connection from the pool.</p>

        <div class="highlighter-rouge"><div class="file">AbstractController.java</div><pre><code class="java">
@Controller
public abstract class AbstractController {
  private RethinkDBPool pool = null;
  private Connection connection = null;

  @Initializer
  public void initialize(RethinkDBPool pool) throws Exception {
    // Use an initializer to dependency inject the connection pool and store
    // a copy on the instance. You could also do this on a constructor, but
    // initializers are nice because they don't require additional code in
    // subclasses.
    this.pool = pool;
  }

  public Connection r() throws Exception {
    if (pool == null) {
      throw new IllegalStateException();
    }

    if (connection == null) {
      // Only reserve a connection from the pool on the first call to r().
      // Means no resources are consumed if controller doesn't need a connection.
      // Return the same connection instance on subsequent calls.
      // NOTE: getConnection may block until a connection becomes available.
      connection = pool.getConnection();
    }

    return connection;
  }

  @Finalizer
  public void finalize() throws Exception {
    // Use a finalizer to return the opened connection (if any) to the pool.
    if (connection != null) {
      connection.close();
    }
  }
}
        </code></pre></div>

        <p>Using the database in a controller is now simple:</p>

        <div class="highlighter-rouge"><div class="file">MyController.java</div><pre><code class="java">
// NOTE: Extend the AbstractController class that we created.
public final class MyController extends AbstractController {
  @Route(path="/", methods={GET})
  public void handleRequest() throws Exception {
    // Just invoke r() to obtain a connection.
    // The connection will be automatically released once we return from the route handler.
    r().table("table").insert(...);

    // The second call to r() returns the same connection the first one did.
    r().table("table2").insert(...);
  }
}
        </code></pre></div>
      </section>

      <section>
        <a name="server_control"></a>
        <h2>Server Control</h2>
        <p><code><a href="https://github.com/lightning-framework/lightning/blob/master/src/main/java/lightning/server/LightningServer.java" target="_blank">LightningServer</a></code> encapsulates a single instance of Lightning with its own configuration. You may run multiple instances of Lightning in the same process by creating multiple instances of <code>LightningServer</code>.</p>
        <p>Each instance of <code>LightningServer</code> may be independently stopped and started.</p>
         <div class="highlighter-rouge"><div class="file">/src/main/java/myapp/AppLauncher.java</div><pre><code class="java">
package myapp;
import lightning.server.*;
import lightning.inject.*;
import lightning.config.*;

public final class AppLauncher {
  public static void main(String[] args) throws Exception {
    Config config = new Config();
    InjectorModule injector = new InjectorModule();

    // ... set up config and injector ...

    // Create a new server.
    LightningServer server = new LightningServer(config, injector);

    // Tell the server to start responding to requests.
    // start() will not return until the server is ready to respond to requests.
    server.start();

    // Block the calling thread until the server is stopped.
    // stop() may be invoked in another thread to stop the server.
    server.join();
  }
}
        </code></pre></div>
      </section>

      <section>
        <a name="packaging_deployment"></a>
        <h2>Packaging &amp; Deployment</h2>
        <p>Lightning applications can be packaged into a stand-alone JAR file for deployment to a production server. The server need only have a JRE 1.8+ to run Lightning. In order to deploy properly, you must make sure that you are following the Maven directory structure guidelines and properly placing resources into the classpath (<code>/src/main/{resources|java}</code>).</p>
        <p>You may use a JAR packager of your choice. We have found the Maven assembly plugin to be very useful and fast at packaging. To utilize the assmebly plugin, you need to modify your <code>pom.xml</code>:</p>

        <div class="highlighter-rouge"><div class="file">/pom.xml</div><pre><code class="xml">
&lt;!-- To build the JAR, run 'mvn assembly:single'.
     Compiled JAR will be in target/ folder. --&gt;

&lt;project&gt;
  ...
  &lt;build&gt;
    ...
    &lt;plugins&gt;
      ...
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;archive&gt;
            &lt;manifest&gt;
              &lt;mainClass&gt;path.to.AppLauncher&lt;/mainClass&gt;
            &lt;/manifest&gt;
          &lt;/archive&gt;
          &lt;descriptorRefs&gt;
            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
          &lt;/descriptorRefs&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      ...
    &lt;/plugins&gt;
    ...
    &lt;resources&gt;
      ...
      &lt;resource&gt;
        &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**&lt;/include&gt;
        &lt;/includes&gt;
        &lt;excludes&gt;
        &lt;/excludes&gt;
      &lt;/resource&gt;
      &lt;resource&gt;
        &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;directory&gt;src/main/java&lt;/directory&gt;
        &lt;includes&gt;
          &lt;include&gt;**&lt;/include&gt;
        &lt;/includes&gt;
        &lt;excludes&gt;
          &lt;exclude&gt;**/*.java&lt;/exclude&gt;
        &lt;/excludes&gt;
      &lt;/resource&gt;
      ...
    &lt;/resources&gt;
    ...
  &lt;/build&gt;
  ...
&lt;/project&gt;
        </code></pre></div>
        <p><strong>Recommendation:</strong> We recommend setting up your launcher class to accept a configuration file as a command-line argument rather than packaging your configuration into the JAR.</p>
        <p>Once packaged to a JAR, you can run your application as you would any other Java JAR:</p>
        <div class="highlighter-rouge"><div class="file">Terminal</div><pre><code class="text">
$ java -jar /path/to/app.jar arg1 arg2 ...
        </code></pre></div>
        <p>You might want to read about optimizing Jetty under high load if you are using Lightning for a very popular application. You can tune the garbage collection parameters, Lightning configuration, and some OS settings to improve your performance.</p>
        <ul>
          <li><a href="https://www.eclipse.org/jetty/documentation/9.3.x/high-load.html" target="_blank">Jetty: High Load</a></li>
          <li><a href="https://www.eclipse.org/jetty/documentation/9.3.x/optimizing.html" target="_blank">Optimizing Jetty</a></li>
        </ul>
      </section>

      <!--
      TODO:
        - Document SimpleHTTPServer
        - Document TOTP
        - Document FlagSpec

      -->

          <!-- END RIGHT -->
        </div>
      </div>
    </div>
    <script type="text/javascript">
      (function() {
        // Trim leading and starting line breaks of code snippets.
        var elements = document.querySelectorAll('div.highlighter-rouge pre code');

        for (var i = 0; i < elements.length; i++) {
          var firstChild = elements[i].firstChild;
          firstChild.textContent = firstChild.textContent.trim();
        }
      })();

      (function() {
        // Generate table of contents.
        var sections = document.querySelectorAll('section');

        for (var i = 0; i < sections.length; i++) {
          var anchor = sections[i].querySelector('a[name]').getAttribute('name');
          var title = sections[i].querySelector('h2').textContent;

          var link = $('<a>');
          link.attr('href', '#' + anchor);
          link.text(title);

          var li = $('<li>');
          link.appendTo(li);
          li.appendTo($('#table_of_contents'));
        }
      })();

      $(document).ready(function() {
        // Handle link clicks within the page.
        var setPage = function() {
          var name = window.location.hash;

          if (name) {
            $('section').hide();
            $('a[name=' + name.substring(1, name.length) + ']').closest('section').show();
            $(window).scrollTop(0);
          }
        }

        if (window.location.hash) {
          setPage();
        } else {
          window.location.hash = "info";
        }

        // Listen for the window URL to change.
        $(window).on('hashchange', function(e) {
          setPage();
        });
      });
    </script>
  </body>
</html>
